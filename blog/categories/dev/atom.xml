<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: dev | blog on github]]></title>
  <link href="http://nekoya.github.io/blog/categories/dev/atom.xml" rel="self"/>
  <link href="http://nekoya.github.io/"/>
  <updated>2013-07-09T10:57:51+09:00</updated>
  <id>http://nekoya.github.io/</id>
  <author>
    <name><![CDATA[nekoya]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[コード内で「現時刻」を気軽に取得してはいけない]]></title>
    <link href="http://nekoya.github.io/blog/2013/07/09/what-time-is-it/"/>
    <updated>2013-07-09T01:20:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2013/07/09/what-time-is-it</id>
    <content type="html"><![CDATA[<p>日付を扱う処理についていろいろまとめたついでに、わりと簡単なことだけど知らないと落とし穴にハマる系のネタを。</p>

<p>日頃いろいろな処理を書いていて、現時刻を扱うこともは少なくないはずです。ですが、これを適当にやっていると困ることが多々あります。</p>

<h2>実行中に「現時刻」を元にした処理が食い違う</h2>

<p>例えばこんなコード。ログ集計とかやってるイメージです。</p>

<pre><code>class Analyzer(object):
    def analyze(self):
        logfile = datetime.datetime.now().strftime('my_log_file.%H')
        self.save(self.analyze_logfile(logfile))

    def save(self, result):
        now = datetime.datetime.now()
        self.result[now.hour] = result
</code></pre>

<p>analyze_logsの実行にやたら時間がかかったり、やんごとない事情で14:57とかに実行して15:02に集計が終わった場合などに悲劇が起きます。</p>

<p>ここまで問題が明らかな場合に限らず、現時刻をその都度取得していると、そのスクリプトにとって「今」がいつを指し示すのかが曖昧になってしまいます。</p>

<p>この意識が薄いままコードを書く習慣が身についてしまうと、いざという時に上記のような問題を抱えたコードを書いてしまいがちなので気を付けたいところです。</p>

<p>この問題に対しては、例えば</p>

<pre><code>    def __init__(self):
        self.target_time = datetime.datetime.now()
</code></pre>

<p>のように、最初に現時刻を取得しておいて、他の箇所ではこの時刻を使って処理します。</p>

<p>この時に現時刻を保存する変数名は、そのままnowとしても構いませんが、その時の処理に応じた適切な名前を付けましょう。上記の例では集計の対象時刻なのでtarget_timeとしています。</p>

<p>それが本当に「現時刻」である必要があるのか、それともたまたま現時刻を元にしているだけで、格納された値には別の意味があるのかの見極めは、設計にも大きな意味を持ちます。</p>

<p>ちなみに、話を分かりやすくするために省略しましたが、本当にログ集計を書く場合は対象時刻は現在ではなくローテート済みの「前の時間」なのでそのへんは調整が必要です。</p>

<h2>再試行したい時に手が出せない</h2>

<p>先のようなログ集計が代表例になります。特定の時間に対する処理をやり直したいとき、現時刻を取得するコードがあちこちにあると改修は大仕事になります。</p>

<p>先のように、現時刻を取得する処理が独立していればオプションで変更可能に拡張することもできるし、いざという時は直接コードを書き換えて緊急回避することだって可能です。</p>

<h2>後から「あの時の処理」を追うのが難しい</h2>

<p>特定の条件を満たしたプレイヤーにレアアイテムを配布する、というユースケースを想定します。</p>

<p>DBにアイテムのレコードをINSERTして、そのレコードには付与時刻のカラムがあったとしましょう。</p>

<p>例えば500件ずつBULK INSERTしたとして、付与時刻をINSERT文を発行する度に現時刻から取っていたら、一度のバッチで複数の「付与時刻」が記録されることになります。</p>

<p>後から「あの時にアイテム付与したユーザのidを全部くれ」と言われた時に、DBから取ってくる付与時刻は一定の期間で範囲検索することになります。また、その指定する範囲に漏れがないことを確実に保証するのは意外と厄介です。</p>

<p>「DBに入ったその瞬間がいつか」を記録したいという場面もあるかも知れませんが、それよりもひとつの意味を持つ処理単位で時刻が統一されていた方が便利なケースが多いのではないでしょうか。</p>

<p>どうせレプリケーションの遅延やらキャッシュやらでconsistencyを保証することが不可能なことも多いはずですし。</p>

<h2>テスタビリティが落ちる</h2>

<p>これは本質的な問題ではないと考える向きもあるかも知れませんが、重要なことだと考えています。</p>

<p>テストを書こうという意志を持っているのに、現時刻を扱うノウハウを持っていないために回りくどいコードを書いてしまったり、この部分のほころびが他にも波及してカバレッジが下がってしまったりという事例を見ています。</p>

<p>そういうことがあると「テスト書くの面倒だからTDDやりたくない」みたいな意識が生まれてしまいがちです。これは大変もったいないことです。</p>

<p>また「テストが書きにくい（書けない）」というのは、言い換えれば設計がよくないという見方もできます。そういうアプローチや考え方を採用するかは別にして、ノウハウとして持っておいて選択肢を増やすことは悪くないでしよう。</p>

<p>ここも先の構成であれば、テストコードで</p>

<pre><code>analyzer = Analyzer()
analyzer.target_time = datetime.datetime(2013, 7, 8, 22, 43, 11)
</code></pre>

<p>このようにtarget_timeを変更するだけで自由にテストが書けます。</p>

<p>テストで現時刻を扱うためのライブラリも各言語で色々あります。Perlの<a href="http://search.cpan.org/~ddick/Test-MockTime-0.12/lib/Test/MockTime.pod">Test::MockTime</a>や、Rubyの<a href="http://rubygems.org/gems/timecop">timecop</a>、Pythonだとそのものズバリは知らないけど<a href="http://www.voidspace.org.uk/python/mock/">mock</a>でmonkey patchを当てることが出来ます。</p>

<p>しかし、こうしたライブラリによるサポートはテスタビリティが確保できない既存のモジュールをメンテナンスする時に使うのが適切だと考えます。最初から入れ替え可能な設計になっていればテストに限らず拡張に対して開かれた形になるので、その方が理想的でしょう。</p>

<h2>現時刻をどこで取るべきか</h2>

<p>簡単なアプリケーションであれば、上記のようにコンストラクタで現時刻を取れば解決するかも知れませんが、実際に書くアプリケーションの大半は一つのクラスで完結するものではないでしょう。じゃあ、どうするか。</p>

<p>原則として、現時刻を取得するのは「外部からの入力を受け取る部分」です。Facadeになるオブジェクトだけが現時刻を取得し、そこから呼ばれるドメイン層のオブジェクトは時刻を受け取るだけにするのが自分のパターンです。</p>

<p>具体的には、バッチであればCLIからパラメータ等を受け取るオブジェクト、WebアプリケーションであればRequestやContextに相当するオブジェクトがその役割を担います。</p>

<p>こうすることで「前はこのクラスで現時刻を取ってたが、その上に別のクラスが挟まったので、ここで現時刻を取っているのは具合が悪い」みたいな問題を回避することができます。</p>

<h2>まとめ</h2>

<ul>
<li>現時刻をあちこちで取るな</li>
<li>入り口で取って使い回せ</li>
<li>nowという名前が適切か考えろ</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[本当は怖いstrptimeと%Y%m%dの関係]]></title>
    <link href="http://nekoya.github.io/blog/2013/06/10/strptime-ymd/"/>
    <updated>2013-06-10T10:33:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2013/06/10/strptime-ymd</id>
    <content type="html"><![CDATA[<p>「%Y%m%d」をstrptimeで処理すると曖昧になることを今更ながらに知りました。</p>

<p>社内で「201312」を渡すとキモいという話が出て、</p>

<blockquote class="twitter-tweet"><p>Pythonでdatetime.datetime.strptime('201312', '%Y%m%d')がエラーにならず1月2日として成立するの具合悪いと思うの</p>&mdash; nekoya (@nekoya) <a href="https://twitter.com/nekoya/status/342897090780876800">June 7, 2013</a></blockquote>


<script async src="http://nekoya.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>ってPostしたら<a href="http://twitter.com/hiratara/">@hiratara</a>さんが「2013129と2013130もキモいぞ」と教えてくれました。</p>

<p>普段は%Y-%-%dを使うんだけど、URLに日付を埋め込む場合はデリミタ無しの方が自然だなーと思ったらご覧の有様だよ。</p>

<p>Python2.7.1</p>

<pre><code>&gt;&gt; datetime.strptime('201312', '%Y%m%d')
datetime.datetime(2013, 1, 2, 0, 0)
&gt;&gt; datetime.strptime('2013129', '%Y%m%d')
datetime.datetime(2013, 12, 9, 0, 0)
&gt;&gt; datetime.strptime('2013130', '%Y%m%d')
datetime.datetime(2013, 1, 30, 0, 0)
</code></pre>

<p>なお、Pythonだけでなく他の言語でも見事にバラバラでﾜﾛﾀ。それぞれ最新版じゃないけど、そう変わらない気がする。</p>

<p>Perl5.12.2 Time::Piece</p>

<pre><code>$ perl -MTime::Piece -le 'print localtime-&gt;strptime("201312", "%Y%m%d")'
Sun Dec  1 00:00:00 2013
$ perl -MTime::Piece -le 'print localtime-&gt;strptime("2013129", "%Y%m%d")'
Mon Dec  9 00:00:00 2013
$ perl -MTime::Piece -le 'print localtime-&gt;strptime("2013130", "%Y%m%d")'
Error parsing time at /Users/ryo/perl5/perlbrew/perls/perl-5.12.2/lib/5.12.2/darwin-2level/Time/Piece.pm line 469.
</code></pre>

<p>PHP5.3.15</p>

<pre><code>$ php -r 'var_dump(new DateTime("201312"));'
object(DateTime)#1 (3) {
  ["date"]=&gt;
  string(19) "2013-06-10 20:13:12"
  ["timezone_type"]=&gt;
  int(3)
  ["timezone"]=&gt;
  string(10) "Asia/Tokyo"
}
$ php -r 'var_dump(new DateTime("2013129"));'
object(DateTime)#1 (3) {
  ["date"]=&gt;
  string(19) "2013-05-09 00:00:00"
  ["timezone_type"]=&gt;
  int(3)
  ["timezone"]=&gt;
  string(10) "Asia/Tokyo"
}
$ php -r 'var_dump(new DateTime("2013130"));'
object(DateTime)#1 (3) {
  ["date"]=&gt;
  string(19) "2013-05-10 00:00:00"
  ["timezone_type"]=&gt;
  int(3)
  ["timezone"]=&gt;
  string(10) "Asia/Tokyo"
}
</code></pre>

<p>Ruby1.9.3p194</p>

<pre><code>% irb
irb(main):001:0&gt; require 'date'
=&gt; true
irb(main):002:0&gt; Date.strptime('201312', '%Y%m%d').to_s
ArgumentError: invalid date
        from (irb):2:in `strptime'
        from (irb):2
        from /Users/ryo/.rbenv/versions/1.9.3-p194/bin/irb:12:in `&lt;main&gt;'
irb(main):003:0&gt; Date.strptime('2013129', '%Y%m%d').to_s
=&gt; "2013-12-09"
irb(main):004:0&gt; Date.strptime('2013130', '%Y%m%d').to_s
ArgumentError: invalid date
        from (irb):4:in `strptime'
        from (irb):4
        from /Users/ryo/.rbenv/versions/1.9.3-p194/bin/irb:12:in `&lt;main&gt;'
</code></pre>

<p>%Y%m%dを取る場合は、strptime任せにせず自分でフォーマットのチェックもしておかないと危険ですね。もしくは、おとなしくデリミタ挟むか。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UMLも捨てたもんじゃない]]></title>
    <link href="http://nekoya.github.io/blog/2013/04/01/useful-uml/"/>
    <updated>2013-04-01T10:30:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2013/04/01/useful-uml</id>
    <content type="html"><![CDATA[<p>UML、最近はあまり名前を聞くこともなくなってきた感があります。</p>

<p>「<a href="http://kohada.2ch.net/test/read.cgi/prog/1314799400/">UMLなんていらない</a>」なんてスレもあったりして、どうにも廃れた物と見る向きもあるようです。</p>

<p>「<a href="http://b.hatena.ne.jp/search/tag?safe=on&amp;sort=popular&amp;q=uml&amp;users=100">UML</a>」タグではてブの人気エントリを探しても、2005〜2007年ぐらいのものが目立つので、注目度という意味では流行ではないのは確かなのかなぁとは思います。</p>

<p>が、このところ有用性を改めて実感することが多いので「UMLいいよ」というエントリを書きます。</p>

<p>上記のスレは賛否両論併せてなかなかいい具合に意見が出ていて面白いのですが、以下を抑えていれば認識としてはいいのではないかと思います。</p>

<ul>
<li>UMLは設計の技法ではない</li>
<li>頭の中を整理するため、あるいは人と共有する際の表現技法である</li>
</ul>


<p><a href="http://kau.li/">弊社</a>では、新しく入社したメンバーにプロダクトの設計を共有したり、新機能の開発をする際の社内レビューなどの際に、シーケンス図っぽいものやクラス図っぽいものを使うことがよくあります。</p>

<p>いきなりコードを読み書きしたり、文章に落とすよりも意志の共有がうまくいく感があって、このところ特に積極的に使うようにしているのですが、手応えは強く感じています。</p>

<p>UMLの厳密な書式ルールには全くこだわりはなく、大まかなイメージだけ伝われば、細かい部分は口頭でフォローすれば十分だと考えていています。そういう意味ではUMLを正しく使っているとは言えないのかも知れませんが、それはそれでいいんじゃないのと。</p>

<p>「廃れた」というよりはある程度のところまで浸透して、ふつうに使われるようになったので、大々的に取り沙汰されることがなくなってきただけではないかという気もしますが、それにしてもWeb+DBやSDで見かけないのはどうなのかなぁ…</p>

<p>UMLと併せて「オブジェクト指向で設計する」みたいなのもあまり目にしない印象があります。自分としてはプログラマとしての根幹を支えるとても大切な技術だと思うのですが、最近は雑誌などでもあまり目にすることがなくて寂しい限りです。</p>

<p>若いエンジニアが責務の切り分けや命名に苦心しているのを見るにつけ、この手の話題はもっと定期的に取り沙汰されてもいいのになぁと思うことがままあります。</p>

<p>面接の時にもこのあたりの質問をするべきか、最近はそんなに重視されないのか迷ったこともありましたが、一頃話題になった<a href="http://www.crackingthecodinginterview.com/content/cracking-coding-interview">Cracing The Coding Interview</a>を読むと、多くの企業が採用に際してオブジェクト指向設計についての技術的な質問項目を設けているというエピソードがあり、それ以来迷うことなく、面接時に積極的にこの手の質問を振るようにしています。</p>

<p>あまり細かい部分を追いかける必要はないし、使えば皆が幸せになれるとか言うつもりもないけど、このへんのテーマは知識として身につけておくとお得なので是非。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[get_user()の何がいかんのか]]></title>
    <link href="http://nekoya.github.io/blog/2013/02/20/what-about-get-user/"/>
    <updated>2013-02-20T08:30:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2013/02/20/what-about-get-user</id>
    <content type="html"><![CDATA[<p><a href="http://nekoya.github.com/blog/2013/02/12/dont-say-check-xxx/">先のエントリ</a>で以下のように述べた伏線の回収エントリとなります。</p>

<blockquote><p>そして、get_user()という名前はサンプルコードにはありがちだが、この名前も闇が深いと思っている。これについてはまた別途取り上げたい。</p></blockquote>

<p>このメソッドを構成する単語であるget, userともに問題があると考えており、それぞれについて見ていきます。</p>

<h2>Userとは具体的に何か</h2>

<p>これはよくある話で、まず自問すべきは「そのUserの定義を教えてください」である。</p>

<p>多くの業務システムではユーザ（アクタ）が複数存在しており、単に「ユーザ」と言った場合に指す対象が文脈によって異なることが多い。</p>

<p>これに対しては、Employee, Staff, Administrator, Visitor, Sponsorなど別の具体的な単語に置き換えられないかを検討することになる。</p>

<p>「ユーザ」が一意なシステムであればUserと名付けるのも妥当だろう（SNSなどが該当するだろうか）。</p>

<p>userについては、より具象化した名前が見付からないかよく検討しましょう、という話で簡単に終わる。</p>

<h2>get_XXX()という名前</h2>

<p>このgetという名前についてはここ数年に渡って思うところがあり、もやもやしていたが、この話題を通してある程度は自分のスタンスが見えてきた。</p>

<p>個人的な経験から、近年のプログラム言語はメソッドとプロパティ（メンバ変数）の境界線が曖昧になる方向に進んでいると感じている。</p>

<p>具体的には、PerlでMoose系モジュールによるlazyとdefaultを使ったアクセサと初期値の定義や、Pythonの@propertyがそう感じるに至った体験である。また、JavaScriptでもクロージャを使うことで似たような感覚に陥ることがある。</p>

<p>ここから生まれた疑問が「メソッドや関数への参照を変数に格納可能な言語において、その内容が現物の値そのものなのか、何らかの処理の結果なのかを区別することに意味はあるのか」というものだ。</p>

<p>書籍『リーダブルコード』では、</p>

<blockquote><p>多くのプログラマは、getで始まるメソッドはメンバの値を返すだけのアクセサ」であるという規約に慣れ親しんでいる。この規約を守らなければ誤解を招く可能性がある。</p></blockquote>

<p>として、get*()にコストの高い処理を組み込むことを戒め、</p>

<blockquote><p>コストの高さが事前にわかるように、このメソッドはcoputeMean()などの名前に変えるべきだろう（あるいは、コストの高くない実装に変えるべきだろう）。</p></blockquote>

<p>と書いている。この論には大筋では同意なのだが、「そもそもgetを付ける必然性はあるのか」という疑念がついて回る。</p>

<p>setterについては言語仕様も含めて一概には言えないが、少なくともgetterはプロパティへのアクセスと区別する必要はないとの思いが日に日に強くなっている。</p>

<p>また、呼び出しのコストについては名前の如何に関わらず、呼び出し元がそこを意識するべきではないとも思う。</p>

<p>少し理想論も入ってくるが、外部に公開しているインタフェースは呼び出し元がその内部の実装を意識することなく利用されるべきであると考えている。非機能要件が機能を制限すべきでない、とも言い換えられる。</p>

<p>現実的には呼び出しコストを完全に無視できないケースは多々あるが、それが命名規則に影響を与えることには違和感がある。</p>

<p>例えば、キャッシュを導入すればそれまで毎回大きなコストがかかっていた処理が、最初の1回だけ高コストで、その後は軽い処理になる。</p>

<p>その計算をアクセサが呼ばれた瞬間でなく、オブジェクトが生成されたタイミングで行えば、メソッドそのものは重い処理ではなくなる。</p>

<p>更には、事前にその集計結果をKVS等に格納することになれば、オブジェクト生成も含めて呼び出しコストの問題は無視できるレベルになるだろう。</p>

<p>このような対策が考えられる問題に対して、命名が影響を受けることには疑問がある。</p>

<p>コストの問題は命名とは別のものとして、別途計測やチューニングの対象とすべきではないか。高コストであっても呼び出し頻度が低ければ問題にならないことも多いだろうし、頻度が高いのであれば、名前で警告するよりもコスト軽減に目を向けた方が実りが多いように思う。</p>

<h2>3行まとめ</h2>

<ul>
<li>抽象化されたサンプルの名前に引きずられるな</li>
<li>アクセサとプロパティの違いは明確にしなくていい</li>
<li>命名と処理コストは別問題として扱え</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ダメなのはcheck_xxxだけではない]]></title>
    <link href="http://nekoya.github.io/blog/2013/02/12/dont-say-check-xxx/"/>
    <updated>2013-02-12T08:23:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2013/02/12/dont-say-check-xxx</id>
    <content type="html"><![CDATA[<p>id:<a href="http://d.hatena.ne.jp/Yamashiro0217/">Yamashiro0217</a>さんの<a href="http://d.hatena.ne.jp/Yamashiro0217/20130210/1360480362">check_xxx がなんでダメなのか - Yamashiro0217の日記</a>が面白かったので、少し掘り下げてみる。</p>

<p>第一印象は「いくら何でも例が恣意的すぎ。check_XXX言うな言いたいだけちゃうんか」だったが、現実は非情であり、こういうコードを押し付けられたこともあるので決して大袈裟ではなかった。</p>

<p>こういう名前が付く場合というのは、往々にしてメソッドの目的が定まっていないことが多い。そこに、is_valid_XXXのような名前を持ち込んで戻り値の型を規定してしまうことは有効なアプローチである。やる人は名前に関わらずどこでもexitするが、それは個別に教育していくしかない。</p>

<p>そんな訳でcheck_XXXは確かに避けたい名前だが、is_valid_x_stateやis_valid_user_about_xもやはりよろしくない。check_user_x_value_and_if_invalid_update_x_and_redirectはネタとしても、その方向性には危険な香りがする。</p>

<p>メソッド名が長くなるのはクラスが自身の責務を外部に放り投げることにつながるからだ。is_valid_user_about_xはその分かりやすい例で、対象となるオブジェクトがUserなのかXなのか分からない。</p>

<p>これは、$user->hasValidX()もしくは$x->isValid()として実装されるべきだろう。メソッド名に対象となりうる物が複数出てきたら、その時点でクラスの責務が揺らいでいるのでリファクタリングした方がよい。</p>

<p>また、メソッド名に具体的な条件を表す文言が出てきた場合は、クラスではなくメソッドが責務を持っている可能性が高いので、これも怪しい匂いである。「メソッド名が処理内容そのままで、何も抽象化されていない」が代表的な症例だろう。</p>

<p>と、ここまで読んで何かおかしいと思ったら、サンプルコードに一つもクラスが無いことに気付いた。オブジェクトが設計されていないので、メソッド名だけを整えたところで根本的な問題が解決しないのだ。</p>

<p>メソッドはオブジェクトの公開インタフェースなので、メソッド自体の名前ももちろん大切だけど、その前提となるオブジェクトのクラス設計の方がもっと大切なので気を付けましょう。クラス設計が不適切だと、名前の付けようもなかったりするし。</p>

<p>元ネタでは簡略化のためにあえてクラスを省略したのかも知れないが、メソッドはオブジェクトと対になって意味を持つものなので、やはり省略すべきではない。</p>

<p>なお、オブジェクトに従属していないPHPの関数はメソッドではなく「サブルーチン」と呼びたい。なので自分には、このサンプルのget_XXXをメソッド名と呼ぶこと自体に違和感がある。</p>

<p>そして、get_user()という名前はサンプルコードにはありがちだが、この名前も闇が深いと思っている。これについてはまた別途取り上げたい。</p>

<p>ちなみに、個人的にはcheck_XXXと聞いて最初に思い浮かぶのはNagiosプラグインなので、boolで成否が返ってくることが期待される。が、Nagiosプラグインもwarn/crit/unknownなど様々な戻り値があるので、確認する対象によっては違う型を返すことがあり、やはり適切でない。</p>
]]></content>
  </entry>
  
</feed>
