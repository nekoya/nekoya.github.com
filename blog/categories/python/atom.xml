<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | blog on github]]></title>
  <link href="http://nekoya.github.io/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://nekoya.github.io/"/>
  <updated>2013-07-03T10:43:16+09:00</updated>
  <id>http://nekoya.github.io/</id>
  <author>
    <name><![CDATA[nekoya]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[MySQL-python1.2.4でdatetimeから文字列の変換方法が変わった件]]></title>
    <link href="http://nekoya.github.io/blog/2013/07/03/mysql-python-datetime-format/"/>
    <updated>2013-07-03T10:32:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2013/07/03/mysql-python-datetime-format</id>
    <content type="html"><![CDATA[<p>MySQL-python（MySQLdb）を上げたら、今まで通ってたテストでwarningが出るようになりました。</p>

<p><a href="https://github.com/farcepest/MySQLdb1/blob/MySQLdb-1.2.4/MySQLdb/times.py">MySQLdb/times.py</a>で以前は</p>

<pre><code>def format_TIMESTAMP(d):
    return d.strftime("%Y-%m-%d %H:%M:%S")
</code></pre>

<p>こうなっていたものが、</p>

<pre><code>def format_TIMESTAMP(d):
    return d.isoformat(" ")
</code></pre>

<p>こうなったのが原因らしいのだけど、<a href="https://github.com/farcepest/MySQLdb1/blob/MySQLdb-1.2.4/HISTORY">Changelog</a>を見てもそれらしい表記がないので少し経緯を追ってみました。</p>

<p>この変更で何が問題になったかというと、</p>

<pre><code>&gt;&gt; import datetime, pytz
&gt;&gt;&gt; datetime.datetime.now(pytz.utc).isoformat(' ')  # aware
'2013-06-27 01:50:16.156481+00:00'
&gt;&gt;&gt; datetime.datetime.now().isoformat(' ')  # naive
'2013-06-27 10:48:30.696072'
</code></pre>

<p>のように、microsecondや時差を含んだ文字列がSQLに渡って「Warning: Incorrect datetime value: '2013-06-27 01:50:16.156481+00:00' for column 〜」という警告が出るようになりました。</p>

<p>履歴を追っていくと、<a href="http://sourceforge.net/p/mysql-python/svn/659/">http://sourceforge.net/p/mysql-python/svn/659/</a> で</p>

<blockquote><p>Use isoformat() instead of strftime() to avoid year limitations of the latter. Fixes #3296395</p></blockquote>

<p>とあって、1900年以前の日付を扱えるようにこの変更を加えたことが分かります。strftime(3)の仕様的にそうなってたけど、そこの制限を外したぜってことらしいです。だけど、この#3296395ってどこのことだ…</p>

<p>該当するチケットは <a href="http://sourceforge.net/p/mysql-python/bugs/311/">#311 executing a datetime column update with year &lt; 1900 fails</a> っぽいけど、BTS移行とかしたんでしょうか。</p>

<p>最初はMySQL5.6でdatetime型がミリ秒対応したらしい（検証してない）ので、それに合わせた施策かなーと思ったらそんなことはなかった。</p>

<p>他にもmicrosecond周りでは <a href="http://sourceforge.net/p/mysql-python/bugs/325/">#325 Datetime fields with microsecond shows as None</a> みたいなチケットが今も動いていたりして、なかなか予断を許さない印象を受けます。</p>

<p>DBのライブラリがdatetimeオブジェクトを適切に扱ってくれるのは素敵だと思ってたけど、なかなか難しいですね。取り急ぎの対処法としては、</p>

<ul>
<li>microsecondやtzinfoを含まないdatetimeオブジェクトだけを扱う</li>
<li>事前に自分で文字列にして渡す</li>
</ul>


<p>のいずれかにわけで、自分のユースケースだとコネクション管理と<a href="http://search.cpan.org/~tokuhirom/SQL-Maker-1.12/lib/SQL/Maker.pm">SQL::Maker</a>の簡易版みたいなことをするラッパーを通しているので、そこで時前でstrftimeして乗り切る感じになりました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pythonのdatetimeで夏時間を扱う]]></title>
    <link href="http://nekoya.github.io/blog/2013/07/02/python-aware-datetime-dst/"/>
    <updated>2013-07-02T15:07:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2013/07/02/python-aware-datetime-dst</id>
    <content type="html"><![CDATA[<p>「<a href="http://nekoya.github.io/blog/2013/06/21/python-datetime/">Pythonの日付処理とTimeZone</a>」を書いた後、Twitterで指摘をもらっていたのを遅ればせながら検証したので、改めてエントリを起こしてみました。</p>

<blockquote class="twitter-tweet"><p>Pythonの日付処理とTimeZone <a href="http://t.co/KK1B5Fot0V">http://t.co/KK1B5Fot0V</a> datetime を tzinfo 付きで生成する場合は pytz.tzinfo.normalize しないと DST 境界を超えるところで存在しない時刻を作りますよ</p>&mdash; Jun Omae⁽⁶⁶ʲ⁵⁾ (@jun66j5) <a href="https://twitter.com/jun66j5/statuses/348421676503011328">June 22, 2013</a></blockquote>


<script async src="http://nekoya.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p><a href="https://twitter.com/jun66j5">@jun66j5</a>さんありがとうございました。</p>

<p>このへんの背景は<a href="http://pytz.sourceforge.net/">pytzのサイト</a>にありますが、そもそもサマータイムに馴染みがないのでどうあるべきかがしっくりきません。</p>

<h2>標準時と夏時間の切り替わり</h2>

<p>ここでは、ニューヨークが属するTimeZoneを例に話を進めます。まずは基本的な用語の整理から。</p>

<ul>
<li><a href="http://ja.wikipedia.org/wiki/%E5%A4%8F%E6%99%82%E9%96%93">DST</a> … daylight saving time、夏時間（サマータイム）のこと</li>
<li><a href="http://ja.wikipedia.org/wiki/%E6%9D%B1%E9%83%A8%E6%A8%99%E6%BA%96%E6%99%82">EST</a> … 東部標準時、UTCより5時間遅れ（-05:00）</li>
<li><a href="http://ja.wikipedia.org/wiki/%E6%9D%B1%E9%83%A8%E5%A4%8F%E6%99%82%E9%96%93">EDT</a> … 東部夏時間、UTCより4時間遅れ（-04:00）</li>
</ul>


<p>とりあえずWikipediaにリンクしときましたが、他にも「<a href="http://www.time-j.net/">Time-j.net 世界時計 - 世界の時間と時差</a>」というサイトの「<a href="http://www.time-j.net/WorldTime/Location/America/New_York">アメリカ / ニューヨークの時差と現在時刻</a>」がいろいろ参考になりました。</p>

<p>2013年は3月10日の午前2時から11月3日の午前2時までが夏時間らしいです。と一口に言っても、夏時間に突入すると同時に現時刻の定義が変わるし、標準時に戻った時も現時刻の定義が変わるのでややこしいんですよね。</p>

<p>正確には「標準時（EST）の3/10 02:00から」「夏時間（EDT）の11/3 02:00まで」が夏時間の適用期間で、その時刻を迎えた時に切り替わるのでこういうことになるようです。</p>

<pre><code>from datetime import datetime
import pytz

fmt = '%Y-%m-%d %H:%M:%S %z(%Z)'

def dump(year, mon, day, hour, min, sec):
    dt = datetime(year, mon, day, hour, min, sec, tzinfo=pytz.utc)
    print dt.astimezone(ny).strftime(fmt)

ny = pytz.timezone('America/New_York')

dump(2013, 3, 10, 6, 59, 59)  # 2013-03-10 01:59:59 -0500(EST)
dump(2013, 3, 10, 7, 0, 0)    # 2013-03-10 03:00:00 -0400(EDT)
dump(2013, 11, 3, 5, 59, 59)  # 2013-11-03 01:59:59 -0400(EDT)
dump(2013, 11, 3, 6, 0, 0)    # 2013-11-03 01:00:00 -0500(EST)
</code></pre>

<p>2013年3月10日の午前2時という時間は消し飛び、夏時間に突入したという結果だけが残る。と考えれば覚えやすいのではないでしょうか。</p>

<h2>datetimeオブジェクトの作り方</h2>

<p>夏時間に該当するdatetimeオブジェクトを作る時、コンストラクタにtzinfoを渡すとこうなります。</p>

<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; import pytz
&gt;&gt;&gt; ny_tz = pytz.timezone('America/New_York')
&gt;&gt;&gt; datetime(2013, 4, 10, 8, 0, tzinfo=ny_tz).strftime(fmt)
'2013-04-10 08:00:00 EST(-0500)'
</code></pre>

<p>ESTなので夏時間になっていません。これは、pytz.timezone()を単体で呼んだだけでは夏時間の判定ができないため、</p>

<ol>
<li>とりあえずESTのtzinfoを返す</li>
<li>datetimeは渡されたtzinfoを単純に取り込む</li>
</ol>


<p>という動作をして、こういう結果を返してしまうものと思われます。</p>

<pre><code>&gt;&gt;&gt; ny_tz.localize(datetime(2013, 4, 10, 8, 0)).strftime(fmt)
'2013-04-10 08:00:00 EDT(-0400)'
</code></pre>

<p>こちらは日付が確定した後にTimeZone情報を与えているので、夏時間に属するawareなdatetimeオブジェクトが取れています。</p>

<pre><code>def localize(dt):
    print ny_tz.localize(dt).strftime(fmt)

localize(datetime(2013, 3, 10, 1, 59, 59))  # 2013-03-10 01:59:59 EST(-0500)
localize(datetime(2013, 3, 10, 2, 0, 0))    # 2013-03-10 02:00:00 EST(-0500)
localize(datetime(2013, 3, 10, 2, 59, 59))  # 2013-03-10 02:59:59 EST(-0500)
localize(datetime(2013, 3, 10, 3, 0, 0))    # 2013-03-10 03:00:00 EDT(-0400)
</code></pre>

<p>2時になったらキング・クリムゾン発動するんじゃないの…</p>

<pre><code>def normalize(dt):
    print ny_tz.normalize(ny_tz.localize(dt)).strftime(fmt)

normalize(datetime(2013, 3, 10, 1, 59, 59))  # 2013-03-10 01:59:59 EST(-0500)
normalize(datetime(2013, 3, 10, 2, 0, 0))    # 2013-03-10 03:00:00 EDT(-0400)
normalize(datetime(2013, 3, 10, 2, 59, 59))  # 2013-03-10 03:59:59 EDT(-0400)
normalize(datetime(2013, 3, 10, 3, 0, 0))    # 2013-03-10 03:00:00 EDT(-0400)
</code></pre>

<p>こちらは2時台も補正されました。ただし、3/10 02:00〜02:59は存在しない時間なので、02:00は03:00と同時刻として処理されます。</p>

<pre><code>&gt;&gt;&gt; ny_tz.localize(datetime(2013, 3, 10, 2, 0, 0)).astimezone(pytz.utc)
datetime.datetime(2013, 3, 10, 7, 0, tzinfo=&lt;UTC&gt;)
&gt;&gt;&gt; ny_tz.localize(datetime(2013, 3, 10, 3, 0, 0)).astimezone(pytz.utc)
datetime.datetime(2013, 3, 10, 7, 0, tzinfo=&lt;UTC&gt;)
</code></pre>

<p>いずれもUTCに変換してしまえば補正されます。UTCではなくJSTにしても同様ですが、TimeZoneの変換をするなら基準はUTCに置いた方が混乱が少ないでしょう。</p>

<p>ただし、この場合でもコンストラクタにtzinfoを渡してしまうと、</p>

<pre><code>&gt;&gt;&gt; datetime(2013, 3, 10, 2, 0, tzinfo=ny_tz).astimezone(pytz.utc)
datetime.datetime(2013, 3, 10, 7, 0, tzinfo=&lt;UTC&gt;)
&gt;&gt;&gt; datetime(2013, 3, 10, 3, 0, tzinfo=ny_tz).astimezone(pytz.utc)
datetime.datetime(2013, 3, 10, 8, 0, tzinfo=&lt;UTC&gt;)
</code></pre>

<p>このように、後者もESTをベースとして処理されてしまいます。pytzの公式にもあるように、datetimeの実装が今の仕様である以上どうにもならないようです。</p>

<p>夏時間を考慮してdatetimeオブジェクトを作る場合は、以下を基本方針とするのがいいでしょう。</p>

<ul>
<li>コンストラクタにはtzinfoを渡さず、naiveなdatetimeオブジェクトをlocalizeする</li>
<li>存在しない時刻が渡る可能性がある時はnormalizeするかUTCに変換する</li>
</ul>


<h2>timedeltaによる演算と夏時間</h2>

<p>tzinfoが夏時間を考慮してくれない問題は、datetimeオブジェクトを作る時だけでなく、timedeltaによる演算時も同様です。</p>

<pre><code>from datetime import timedelta

def offset(seconds):
    dt = ny_tz.localize(datetime(2013, 3, 10, 1, 59, 59))
    dt += timedelta(seconds=seconds)
    print dt.strftime(fmt)

offset(0)     # 2013-03-10 01:59:59 EST(-0500)
offset(1)     # 2013-03-10 02:00:00 EST(-0500)
offset(3600)  # 2013-03-10 02:59:59 EST(-0500)
offset(3601)  # 2013-03-10 03:00:00 EST(-0500)
</code></pre>

<p>夏時間に突入しても、TimeZoneはESTのままです。</p>

<pre><code>def offset_n(seconds):
    dt = ny_tz.localize(datetime(2013, 3, 10, 1, 59, 59))
    dt += timedelta(seconds=seconds)
    print ny_tz.normalize(dt).strftime(fmt)

offset_n(0)     # 2013-03-10 01:59:59 EST(-0500)
offset_n(1)     # 2013-03-10 03:00:00 EDT(-0400)
offset_n(3600)  # 2013-03-10 03:59:59 EDT(-0400)
offset_n(3601)  # 2013-03-10 04:00:00 EDT(-0400)
</code></pre>

<p>normalizeしてやると、補正されてEDTになります。</p>

<p>ただ、夏時間のように時間の定義が途中で変わるような条件で演算するのはあまりに複雑なので、事前にUTCに変換してしまった方が安全でしょう。</p>

<pre><code>&gt;&gt;&gt; datetime(2013, 3, 10, 6, 59, 59, tzinfo=pytz.utc).astimezone(ny_tz).strftime(fmt)
'2013-03-10 01:59:59 EST(-0500)'
&gt;&gt;&gt; datetime(2013, 3, 10, 7, 0, 0, tzinfo=pytz.utc).astimezone(ny_tz).strftime(fmt)
'2013-03-10 03:00:00 EDT(-0400)'
</code></pre>

<p>astimezoneで変換した場合はnormalizeは不要なので、夏時間を意識する必要はありません。</p>

<p>特にテストを書く場合に、夏時間とその期間外でUTCからの時差が変わってテストケースに影響が出るのは好ましくないと考えます。</p>

<p>本件に限らず複数のTimeZoneを扱う場合は、「内部ではUTCで保持し、出力する段階でlocaltimeに変換する」のが間違いが起きにくいでしょう。文字コードで「内部ではUnicodeで保持し、出力する段階でUTF-8等に変換する」というのと同じですね。</p>

<h2>まとめ</h2>

<ul>
<li>夏時間がある場合はコンストラクタにtzinfoを渡さない</li>
<li>時刻を扱う場合は内部ではUTCで持つと混乱が少ない（はず）</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pythonの日付処理とTimeZone]]></title>
    <link href="http://nekoya.github.io/blog/2013/06/21/python-datetime/"/>
    <updated>2013-06-21T10:04:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2013/06/21/python-datetime</id>
    <content type="html"><![CDATA[<p>日付周りの処理というのはとても難しい問題で、特にTimeZoneが絡むと基本的に大変なことになります。</p>

<p>Pythonは標準で用意されているdatetimeモジュールが高機能なので、それを使っておけば間違いない感があって、そういう意味では安心感があります。</p>

<p>とは言え、その扱いにはやはり注意が必要で、現時点でこうするのがいいかなーと思っていることをつらつらと記録したエントリがこちらです。</p>

<p>基本的にはMacのPython2.7.1で検証して、おやっと思ったところはCentOS5.8のPython2.6.5やUbuntu12.04のPython2.7.3で追試しています。</p>

<p>なお、datetime.datetimeと書くのがだるいので本文中では、</p>

<pre><code>from datetime import datetime
</code></pre>

<p>を前提としています。</p>

<h2>naiveとaware</h2>

<p><a href="http://docs.python.jp/2/library/datetime.html">公式ドキュメント</a>にそのまま載ってるけど、datetimeオブジェクトは自身がTimeZone情報を持つ（aware）場合と、持たない（naive）場合があります。</p>

<p>明示的に指定しない限りnaiveになるため、プログラマは自身が「そのオブジェクトがどのTimeZoneに属するか」を常に間違いなく扱う必要があります。</p>

<p>で、これは当然難しい。JSTとUTCぐらいならまだしも、様々なタイムゾーンを扱うシステムでは常に正しい値を扱うことは至難の業と言ってもいい。</p>

<p>「基本はUTCで扱い、localtimeの場合は変数名にlocalと付ける」みたいなルールで頑張っても、モジュールをまたぐ時に変換間違えて残念なことになりかねません。</p>

<p>これに対して、awareなオブジェクトは内部にTimeZone情報を持っているので、そういうケースでも安心できます。</p>

<pre><code>&gt;&gt;&gt; import pytz
&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; datetime.now(pytz.utc)
datetime.datetime(2013, 5, 10, 7, 38, 56, 442741, tzinfo=&lt;UTC&gt;)
&gt;&gt;&gt; datetime(2013, 5, 16, tzinfo=pytz.timezone('Asia/Tokyo'))
datetime.datetime(2013, 5, 16, 0, 0, tzinfo=&lt;DstTzInfo 'Asia/Tokyo' CJT+9:00:00 STD&gt;)
</code></pre>

<p>こんな感じで、原則として全てのdatetimeオブジェクトはawareな状態で扱うようにしています。utcnow()はtzinfoを受け取れないので、UTCにする場合でも必ずnow()を使います。</p>

<h3>pytzの位置付け</h3>

<p>TimeZoneを表すには<a href="http://pytz.sourceforge.net/">pytz</a>を使っています。可能であればサードパーティのライブラリではなく、全て標準モジュールで済ませたいところですが、pytzは<a href="http://docs.python.jp/3.3/library/datetime.html#tzinfo-objects">Python3.3の公式ドキュメント</a>でも、</p>

<blockquote><p>pytz は最新の情報を含み、使用を推奨されています。</p></blockquote>

<p>とお墨付きが出ているので標準に近いモジュールということで利用しています。</p>

<h3>naiveとawareの変換、あるいはTimeZone変更</h3>

<p>naiveとawareの変換は、公式にあるようにreplaceを使います。naiveなdatetimeオブジェクトとawareなそれでは比較や演算が出来ないので、意外と使う場面はあります。</p>

<blockquote><p>単にタイムゾーンオブジェクト tz を datetime オブジェクト dt に追加したいだけで、日付や時刻データへの調整を行わないのなら、dt.replace(tzinfo=tz) を使ってください。単に aware な datetime オブジェクト dt からタイムゾーンオブジェクトを除去したいだけで、日付や時刻データの変換を行わないのなら、dt.replace(tzinfo=None) を使ってください。</p></blockquote>

<p>naive→aware</p>

<pre><code>&gt;&gt;&gt; now = datetime.now()
&gt;&gt;&gt; now
datetime.datetime(2013, 6, 18, 2, 15, 2, 485439)
&gt;&gt;&gt; now.replace(tzinfo=pytz.utc)
datetime.datetime(2013, 6, 18, 2, 15, 2, 485439, tzinfo=&lt;UTC&gt;)
</code></pre>

<p>aware→naive</p>

<pre><code>&gt;&gt;&gt; now = datetime.now(pytz.utc)
&gt;&gt;&gt; now
datetime.datetime(2013, 6, 17, 17, 15, 43, 157502, tzinfo=&lt;UTC&gt;)
&gt;&gt;&gt; now.replace(tzinfo=None)
datetime.datetime(2013, 6, 17, 17, 15, 43, 157502)
</code></pre>

<p>awareなオブジェクトの持っているTimeZone情報の変更は、replaceではなくastimezoneで以下のように。</p>

<pre><code>&gt;&gt;&gt; now = datetime.now(pytz.utc)
&gt;&gt;&gt; now
datetime.datetime(2013, 5, 10, 7, 55, 30, 9529, tzinfo=&lt;UTC&gt;)
&gt;&gt;&gt; now.astimezone(pytz.timezone('Asia/Tokyo'))
datetime.datetime(2013, 5, 10, 16, 55, 30, 9529, tzinfo=&lt;DstTzInfo 'Asia/Tokyo' JST+9:00:00 STD&gt;)
</code></pre>

<h2>UNIXTIMEを扱う</h2>

<p>PythonでUNIXTIMEを得る方法として、よく紹介されるのが</p>

<pre><code>&gt;&gt;&gt; int(time.mktime(datetime.now().timetuple()))
1371682685
</code></pre>

<p>です。intでくくらないと「1371682685.0」のようなfloatが返ってきます。これはこれでいいのですが、datetimeオブジェクトからUNIXTIMEを得ようとすると、</p>

<pre><code>&gt;&gt;&gt; int(time.mktime(datetime(1970, 1, 1).timetuple()))
-32400
&gt;&gt;&gt; int(time.mktime(datetime(1970, 1, 1, tzinfo=pytz.utc).timetuple()))
-32400
&gt;&gt;&gt; int(time.mktime(datetime(1970, 1, 1, tzinfo=pytz.timezone('Asia/Tokyo')).timetuple()))
-32400
</code></pre>

<p>どうやってもUTCを認識してくれない。time.mktimeはtzinfoに対応しておらず、localtimeを受けることになっているのが原因です。</p>

<p><a href="http://docs.python.jp/2/library/time.html">timeモジュールのドキュメント</a>にそのあたりのルールが書いてあって、UTCを扱う場合はcalendar.timegm()を使えとのこと。</p>

<pre><code>&gt;&gt;&gt; calendar.timegm(datetime(1970, 1, 1).timetuple())
0
&gt;&gt;&gt; calendar.timegm(datetime(1970, 1, 1, tzinfo=pytz.utc).timetuple())
0
</code></pre>

<p>今度はうまくいきましたが、入力値をUTCとして解釈するので</p>

<pre><code>&gt;&gt;&gt; calendar.timegm(datetime(1970, 1, 1, tzinfo=pytz.timezone('Asia/Tokyo')).timetuple())
0
</code></pre>

<p>こんな風にlocaltimeの1970-01-01 00:00:00を渡しても0が返ってきます。要注意。</p>

<p>ちなみに、<a href="http://docs.python.jp/2/library/calendar.html#calendar.timegm">calendar.timegm()</a>は</p>

<blockquote><p>関連はありませんが便利な関数で、 time モジュールの gmtime() 関数の戻値のような時間のタプルを受け取り、 1970年を起点とし、POSIX規格のエンコードによるUnixのタイムスタンプに相当する値を返します。実際、 time.gmtime() と timegm() は反対の動作をします。
バージョン 2.0 で追加.</p></blockquote>

<p>なんて紹介されていて、昔はのどかだったんだなぁと思いを馳せる次第です。</p>

<h3>結局どうすればいいのか</h3>

<p>ベンチ取ってみたら、UTCなdatetimeオブジェクトをcalendar.timegm()にかけるのが一番速かったので、現時刻を表すUNIXTIMEを取得するには、</p>

<pre><code>calendar.timegm(datetime.utcnow().timetuple())
</code></pre>

<p>が最適解でしょう。</p>

<p>datetimeオブジェクトを変換する場合は何を優先するかによりますが、基本的には安全性を重視して</p>

<pre><code>calendar.timegm(dt.astimezone(pytz.utc).timetuple())
</code></pre>

<p>とawareなdatetimeオブジェクトを確実にUTCにした上でcalendar.timegm()にかけるのがいいでしょう。</p>

<p>dtが元々UTCの場合はastimezone()は不要ですが、その場合は実行コスト自体が小さくなるのでやはり上記の形式が最適と考えます。</p>

<p>速度を求める場合は、</p>

<ul>
<li>dtがUTCならcalendar.timegm()</li>
<li>dtがlocalならtime.mktime()</li>
</ul>


<p>と変換する時点でdtのTimeZoneを確実に制御してやる必要があります。この場合、datetimeオブジェクト自体もnaiveな方が若干速くなりました。</p>

<p>datetimeオブジェクトに、tzinfoを考慮してUNIXTIMEを算出してくれるメソッドが生えていればこんなに考えなくていいのに…</p>

<h3>strftimeでUNIXTIMEを取る</h3>

<p>ちなみに、プラットフォーム依存なので公式ドキュメントには記載されていませんが、</p>

<pre><code>&gt;&gt;&gt; datetime.now().strftime('%s')
'1371683864'
</code></pre>

<p>strftimeで%sを使うことでUNIXTIMEが取れます。</p>

<pre><code>&gt;&gt;&gt; datetime(1970, 1, 1).strftime('%s')
'-32400'
&gt;&gt;&gt; datetime(1970, 1, 1, tzinfo=pytz.utc).strftime('%s')
'-32400'
</code></pre>

<p>こいつも手元では、localtimeを前提としたtzinfo非対応の挙動を示しました。検証してないけど、strftime(3)を使っててWindows非対応とかそういうことですかね。</p>

<p>ベンチ取ったらcalendar.timegm()よりも遅かったので、特に使うメリットは無さそうです。</p>

<h3>UNIXTIME to datetime</h3>

<p>次にUNIXTIMEからdatetimeオブジェクトを作る方法です。</p>

<pre><code>&gt;&gt;&gt; datetime.utcfromtimestamp(1337914193)
datetime.datetime(2012, 5, 25, 2, 49, 53)
</code></pre>

<p>するとnaiveになってしまいます。先のnow()とutcnow()の関係と同様、utcfromtimestamp()ではなくfromtimestamp()にtzinfoを渡すアプローチを採ります。</p>

<pre><code>&gt;&gt;&gt; datetime.fromtimestamp(1337914193, pytz.utc)
datetime.datetime(2012, 5, 25, 2, 49, 53, tzinfo=&lt;UTC&gt;)
</code></pre>

<h2>datetime.dateもtzinfo非対応</h2>

<p>年・月・日で構成される、dateオブジェクトは残念ながらTimeZone情報を持つことができません。</p>

<p>日付だって時差の影響を受けるのに、どうしてこうなっているのでしょう。残念。</p>

<p>仕方がないので純粋に日付を扱いたい場合も、datetimeオブジェクトを作って時刻関連の情報をreplace()でつぶしています。</p>

<pre><code>&gt;&gt;&gt; datetime.now(pytz.utc).replace(hour=0,minute=0,second=0,microsecond=0)
datetime.datetime(2013, 6, 20, 0, 0, tzinfo=&lt;UTC&gt;)
</code></pre>

<p>replace漏れがあると悲劇につながりかねないのが不安要素ではある。</p>

<p>あと、datetimeもtoday()があって日付だけ取得できるように見えるけど、</p>

<pre><code>&gt;&gt;&gt; datetime.today()
datetime.datetime(2013, 6, 20, 12, 8, 14, 929174)
</code></pre>

<p>時刻も込みで返ってくるので、そういう用途には使えません。</p>

<blockquote><p>datetime.fromtimestamp(time.time()) と等価です
http://docs.python.jp/2/library/datetime.html#datetime.datetime.today</p>

<p>このメソッドは today() と同様ですが、可能ならば time.time() タイムスタンプを通じて得ることができる、より高い精度で時刻を提供します
http://docs.python.jp/2/library/datetime.html#datetime.datetime.now</p></blockquote>

<p>あたりの説明もなんだか微妙…</p>

<h2>strptimeがTimeZoneを無視する</h2>

<p>先日「<a href="http://nekoya.github.io/blog/2013/06/10/strptime-ymd/">本当は怖いstrptimeと%Y%m%dの関係</a>」でも登場したstrptimeですが、TimeZoneの情報を与えてもnaiveなdatetimeオブジェクトしか作ってくれません。</p>

<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; datetime.strptime('2012-06-18 UTC', '%Y-%m-%d %Z')
datetime.datetime(2012, 6, 18, 0, 0)
</code></pre>

<p>仕方がないので、strptimeの後に続けてtzinfoだけ埋め込んでやります。</p>

<pre><code>&gt;&gt;&gt; import pytz
&gt;&gt;&gt; datetime.strptime('2012-06-18 12:31:07', '%Y-%m-%d %H:%M:%S').replace(tzinfo=pytz.utc)
datetime.datetime(2012, 6, 18, 12, 31, 7, tzinfo=&lt;UTC&gt;)
</code></pre>

<h2>まとめ</h2>

<ul>
<li>datetimeオブジェクトはawareな状態で扱おう</li>
<li>UNIXTIMEの扱いはTimeZoneを意識して</li>
<li>UTCを基準にcalendar.timegmとdatetime.fromtimestampがよさそう</li>
<li>dateやstrptimeはtzinfo非対応なので要注意</li>
</ul>


<p>本稿での検証に使ったベンチマークスクリプトは<a href="https://gist.github.com/nekoya/5819512">https://gist.github.com/nekoya/5819512</a>にまとめておきました。</p>

<p>1.4GHzのCore2Duoを積んだMacBookAirだと結構な差が付いたけど、SandyBridge Core i7-2600 @3.4GHzで走らせたら3倍ぐらい速くなってあまり気にならなくなってしまった。買い換え時？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PythonでTest::TCP的なことをするライブラリをPyPIに上げました]]></title>
    <link href="http://nekoya.github.io/blog/2013/05/27/python-tcptest/"/>
    <updated>2013-05-27T16:25:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2013/05/27/python-tcptest</id>
    <content type="html"><![CDATA[<p>Perlでいうところの<a href="http://search.cpan.org/~tokuhirom/Test-TCP-1.27/lib/Test/TCP.pm">Test::TCP</a>相当のことをPythonでやるライブラリをPyPIに上げました。ようやくPyPIデビューです。</p>

<ul>
<li><a href="https://github.com/nekoya/python-tcptest">https://github.com/nekoya/python-tcptest</a></li>
<li><a href="https://pypi.python.org/pypi/tcptest">https://pypi.python.org/pypi/tcptest</a></li>
</ul>


<p>Test::TCPはPerlでテスト時に一時的にサーバを起動したりする処理の基盤となるライブラリです。同等のことをPythonでやるのに適当なものが見当たらなかったので自分で書いたという経緯です。</p>

<p>社内では以前からこの仕組みを使ってテストを書いていたのですが、自社のconfig系のライブラリとの結合を排除して、再構成したものになります。今回こうして公開するにあたって、関数名をオリジナルのPerl版に近付けたり、TestServerの実装を全面的に見直したりしました。</p>

<p>tcptestパッケージにはTest::TCP本体だけでなく、memcachedとredisのテストサーバ実装も含まれています。Perlでは<a href="http://search.cpan.org/~dmaki/Test-Memcached-0.00004/lib/Test/Memcached.pm">Test::Memcached</a>や<a href="http://search.cpan.org/~typester/Test-RedisServer-0.12/lib/Test/RedisServer.pm">Test::RedisServer</a>のように別のライブラリとしてリリースされていますが、名前空間がバラバラになるのも微妙な気がしたので同一のパッケージにまとめました。</p>

<p>PyPIにアップロードすること自体は参考資料もたくさんあり難しくないのですが、どういう名前付けをすべきかなど運営上のルールが今ひとつ分からず、まだ戸惑っている面があります。大文字小文字とか-_.のどれで区切るのかとか。あと、bdistとかbdist_eggはPure Pythonのライブラリだと不要だと思うけどよく分からない。</p>

<p>なお、今回のtcptestは最初test.tcpという名前空間を使おうとしたのですが、Python標準のtestパッケージと干渉することが判明したので衝突回避のためこの名前になりました。</p>

<p>自社プロダクト間の名前空間であれば、pkgutil.extend_pathを使って回避するのですが、標準ライブラリはともかくとして、PyPIのライブラリ同士での衝突はどう回避してるんだろう。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PerlのCrypt::CBCとPythonのPyCryptoで暗号文字列をやりとりする]]></title>
    <link href="http://nekoya.github.io/blog/2013/03/12/python-crypt-cbc/"/>
    <updated>2013-03-12T09:49:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2013/03/12/python-crypt-cbc</id>
    <content type="html"><![CDATA[<p>ここ数年はPerlで暗号を扱う時は<a href="http://search.cpan.org/~jesus/Mcrypt-2.5.7.0/Mcrypt.pm">Mcrypt</a>を使っていますが、少し前の時代だと<a href="http://search.cpan.org/~lds/Crypt-CBC-2.32/CBC.pm">Crypt::CBC</a>を使ったりしてました。世間の流れは知らないけど、Mcrypt使っておけば他のシステムとデータをやりとりする時にお互いやりやすいよねという。</p>

<p>Crypt::CBCで作られた暗号文字列をPythonで復号するケースがあったのですが、そのまま素直にやるとうまくいきません。</p>

<p>padding周りかなと思ったけど、どうやらkeyがそのままでは使えないらしい。stackoverflowにズバリそのまま<a href="http://stackoverflow.com/questions/14859006/using-pycrypto-to-decrypt-perl-encrypted-password">Using PyCrypto to decrypt Perl encrypted password</a>があったのでメモ。</p>

<p><div><script src='https://gist.github.com/5088592.js?file=publish_hex_key.pl'></script>
<noscript><pre><code>use strict;
use warnings;

# http://stackoverflow.com/questions/14859006/using-pycrypto-to-decrypt-perl-encrypted-password

use Crypt::CBC;

my $key = shift or die '[usage] hex_key.pl key';

my $cipher = Crypt::CBC-&gt;new({
        'key'            =&gt; $key,
        'cipher'         =&gt; 'Blowfish',
        'iv'             =&gt; '12345678',
        'regenerate_key' =&gt; 1,
        'padding'        =&gt; 'standard',
        'prepend_iv'     =&gt; 0,
    });

$cipher-&gt;encrypt('ShutTheFuckUpAndWriteSomeCode');
print unpack('H*', $cipher-&gt;key), &quot;\n&quot;;</code></pre></noscript></div>
</p>

<p>こんな具合にして変換したkeyをPythonのコードに埋め込みます。</p>

<p><div><script src='https://gist.github.com/5088592.js?file=decrypt.py'></script>
<noscript><pre><code>import base64
from Crypto.Cipher import Blowfish
from binascii import unhexlify
from struct import pack

key = unhexlify('144a6b229633360207ff9c79016fc49426f1814727b663bc39df05df9a1892073e2812df9492c1e952aac68d1ddfefba635d3a33aba21535')  # &quot;thisiskey&quot;
iv = '123abc45'


def enc(str):
    plen = Blowfish.block_size - len(str) % Blowfish.block_size
    padding = [plen] * plen
    pad_str = str + pack('b' * plen, *padding)
    cipher = Blowfish.new(key, Blowfish.MODE_CBC, iv)
    return base64.urlsafe_b64encode(cipher.encrypt(pad_str))


def dec(str):
    plen = 4 - len(str) &amp; 3
    pad_str = str + '=' * plen
    cipher = Blowfish.new(key, Blowfish.MODE_CBC, iv)
    dec = cipher.decrypt(base64.urlsafe_b64decode(pad_str))
    num_padding = ord(dec[-1])
    return dec[:(-1 * num_padding)]

assert enc('1234567') == '7Zbfy4S_B28='
assert enc('12345678') == '_V5IPxYq4omALzIyl10aMw=='

assert enc('hello world') == 'V6r02_ivXP2ChJ0DGd_7aw=='
assert dec('V6r02_ivXP2ChJ0DGd_7aw==') == 'hello world'
assert dec('V6r02_ivXP2ChJ0DGd_7aw') == dec('V6r02_ivXP2ChJ0DGd_7aw=') == dec('V6r02_ivXP2ChJ0DGd_7aw==') == dec('V6r02_ivXP2ChJ0DGd_7aw===')</code></pre></noscript></div>
</p>

<p>あとはpaddingをそれっぽく調整して、こんなもんでいけたっぽいです。</p>
]]></content>
  </entry>
  
</feed>
