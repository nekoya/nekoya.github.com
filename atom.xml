<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[blog on github]]></title>
  <link href="http://nekoya.github.io/atom.xml" rel="self"/>
  <link href="http://nekoya.github.io/"/>
  <updated>2013-07-09T11:07:15+09:00</updated>
  <id>http://nekoya.github.io/</id>
  <author>
    <name><![CDATA[nekoya]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[コード内で「現時刻」を気軽に取得してはいけない]]></title>
    <link href="http://nekoya.github.io/blog/2013/07/09/what-time-is-it/"/>
    <updated>2013-07-09T01:20:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2013/07/09/what-time-is-it</id>
    <content type="html"><![CDATA[<p>日付を扱う処理についていろいろまとめたついでに、わりと簡単なことだけど知らないと落とし穴にハマる系のネタを。</p>

<p>日頃いろいろな処理を書いていて、現時刻を扱うこともは少なくないはずです。ですが、これを適当にやっていると困ることが多々あります。</p>

<h2>実行中に「現時刻」を元にした処理が食い違う</h2>

<p>例えばこんなコード。ログ集計とかやってるイメージです。</p>

<pre><code>class Analyzer(object):
    def analyze(self):
        logfile = datetime.datetime.now().strftime('my_log_file.%H')
        self.save(self.analyze_logfile(logfile))

    def save(self, result):
        now = datetime.datetime.now()
        self.result[now.hour] = result
</code></pre>

<p>analyze_logsの実行にやたら時間がかかったり、やんごとない事情で14:57とかに実行して15:02に集計が終わった場合などに悲劇が起きます。</p>

<p>ここまで問題が明らかな場合に限らず、現時刻をその都度取得していると、そのスクリプトにとって「今」がいつを指し示すのかが曖昧になってしまいます。</p>

<p>この意識が薄いままコードを書く習慣が身についてしまうと、いざという時に上記のような問題を抱えたコードを書いてしまいがちなので気を付けたいところです。</p>

<p>この問題に対しては、例えば</p>

<pre><code>    def __init__(self):
        self.target_time = datetime.datetime.now()
</code></pre>

<p>のように、最初に現時刻を取得しておいて、他の箇所ではこの時刻を使って処理します。</p>

<p>この時に現時刻を保存する変数名は、そのままnowとしても構いませんが、その時の処理に応じた適切な名前を付けましょう。上記の例では集計の対象時刻なのでtarget_timeとしています。</p>

<p>それが本当に「現時刻」である必要があるのか、それともたまたま現時刻を元にしているだけで、格納された値には別の意味があるのかの見極めは、設計にも大きな意味を持ちます。</p>

<p>ちなみに、話を分かりやすくするために省略しましたが、本当にログ集計を書く場合は対象時刻は現在ではなくローテート済みの「前の時間」なのでそのへんは調整が必要です。</p>

<h2>再試行したい時に手が出せない</h2>

<p>先のようなログ集計が代表例になります。特定の時間に対する処理をやり直したいとき、現時刻を取得するコードがあちこちにあると改修は大仕事になります。</p>

<p>先のように、現時刻を取得する処理が独立していればオプションで変更可能に拡張することもできるし、いざという時は直接コードを書き換えて緊急回避することだって可能です。</p>

<h2>後から「あの時の処理」を追うのが難しい</h2>

<p>特定の条件を満たしたプレイヤーにレアアイテムを配布する、というユースケースを想定します。</p>

<p>DBにアイテムのレコードをINSERTして、そのレコードには付与時刻のカラムがあったとしましょう。</p>

<p>例えば500件ずつBULK INSERTしたとして、付与時刻をINSERT文を発行する度に現時刻から取っていたら、一度のバッチで複数の「付与時刻」が記録されることになります。</p>

<p>後から「あの時にアイテム付与したユーザのidを全部くれ」と言われた時に、DBから取ってくる付与時刻は一定の期間で範囲検索することになります。また、その指定する範囲に漏れがないことを確実に保証するのは意外と厄介です。</p>

<p>「DBに入ったその瞬間がいつか」を記録したいという場面もあるかも知れませんが、それよりもひとつの意味を持つ処理単位で時刻が統一されていた方が便利なケースが多いのではないでしょうか。</p>

<p>どうせレプリケーションの遅延やらキャッシュやらでconsistencyを保証することが不可能なことも多いはずですし。</p>

<h2>テスタビリティが落ちる</h2>

<p>これは本質的な問題ではないと考える向きもあるかも知れませんが、重要なことだと考えています。</p>

<p>テストを書こうという意志を持っているのに、現時刻を扱うノウハウを持っていないために回りくどいコードを書いてしまったり、この部分のほころびが他にも波及してカバレッジが下がってしまったりという事例を見ています。</p>

<p>そういうことがあると「テスト書くの面倒だからTDDやりたくない」みたいな意識が生まれてしまいがちです。これは大変もったいないことです。</p>

<p>また「テストが書きにくい（書けない）」というのは、言い換えれば設計がよくないという見方もできます。そういうアプローチや考え方を採用するかは別にして、ノウハウとして持っておいて選択肢を増やすことは悪くないでしよう。</p>

<p>ここも先の構成であれば、テストコードで</p>

<pre><code>analyzer = Analyzer()
analyzer.target_time = datetime.datetime(2013, 7, 8, 22, 43, 11)
</code></pre>

<p>このようにtarget_timeを変更するだけで自由にテストが書けます。</p>

<p>（追記）テストで現時刻を扱うためのライブラリも各言語で色々あります。Perlの<a href="http://search.cpan.org/~ddick/Test-MockTime-0.12/lib/Test/MockTime.pod">Test::MockTime</a>や、Rubyの<a href="http://rubygems.org/gems/timecop">timecop</a>、Pythonだとそのものズバリは知らないけど<a href="http://www.voidspace.org.uk/python/mock/">mock</a>でmonkey patchを当てることが出来ます。</p>

<p>これはこれで有効な手立てですが、こうしたライブラリに頼らずとも一貫した現時刻を扱えた方がいいでしょう。テストだけであればそうした回避策も有効ですが、最初からその部分が入れ替え可能な設計にしておいた方がより堅いアプローチだと考えます。</p>

<p>また、そういったライブラリでパッチを当ててテストを通した場合、そのテスト内では現時刻が固定されるため、先に挙げた問題を含んだコードがそのまま生き延びてしまうリスクが高まります。</p>

<h2>現時刻をどこで取るべきか</h2>

<p>簡単なアプリケーションであれば、上記のようにコンストラクタで現時刻を取れば解決するかも知れませんが、実際に書くアプリケーションの大半は一つのクラスで完結するものではないでしょう。じゃあ、どうするか。</p>

<p>原則として、現時刻を取得するのは「外部からの入力を受け取る部分」です。Facadeになるオブジェクトだけが現時刻を取得し、そこから呼ばれるドメイン層のオブジェクトは時刻を受け取るだけにするのが自分のパターンです。</p>

<p>具体的には、バッチであればCLIからパラメータ等を受け取るオブジェクト、WebアプリケーションであればRequestやContextに相当するオブジェクトがその役割を担います。</p>

<p>こうすることで「前はこのクラスで現時刻を取ってたが、その上に別のクラスが挟まったので、ここで現時刻を取っているのは具合が悪い」みたいな問題を回避することができます。</p>

<h2>まとめ</h2>

<ul>
<li>現時刻をあちこちで取るな</li>
<li>入り口で取って使い回せ</li>
<li>nowという名前が適切か考えろ</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pythonでdatetimeにtzinfoを付与するのにreplaceを使ってはいけない]]></title>
    <link href="http://nekoya.github.io/blog/2013/07/05/python-datetime-with-jst/"/>
    <updated>2013-07-05T12:24:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2013/07/05/python-datetime-with-jst</id>
    <content type="html"><![CDATA[<p>Pythonでnaiveなdatetimeオブジェクトにtzinfoを付けてawareにするには、<a href="http://docs.python.jp/2/library/datetime.html#datetime.datetime.astimezone">公式</a>には</p>

<blockquote><p>単にタイムゾーンオブジェクト tz を datetime オブジェクト dt に追加したいだけで、日付や時刻データメンバへの調整を行わないのなら、 dt.replace(tzinfo=tz) を使ってください。</p></blockquote>

<p>こう書かれているのですが、どうもこの方法は夏時間の扱い以外にも問題があるようです。</p>

<pre><code>&gt;&gt;&gt; import datetime, pytz
&gt;&gt;&gt; jst = pytz.timezone('Asia/Tokyo')
&gt;&gt;&gt; datetime.datetime.now(jst)
datetime.datetime(2013, 7, 5, 12, 23, 1, 962735, tzinfo=&lt;DstTzInfo 'Asia/Tokyo' JST+9:00:00 STD&gt;)
&gt;&gt;&gt; datetime.datetime.now().replace(tzinfo=jst)
datetime.datetime(2013, 7, 5, 12, 23, 9, 143578, tzinfo=&lt;DstTzInfo 'Asia/Tokyo' CJT+9:00:00 STD&gt;)
</code></pre>

<p>replaceでtzinfoを付与すると、JSTではなくCJTとなります。CentOS5.8 + Python2.6.5とSnowLeopard + Python2.7.1で同じ結果になりました。</p>

<ul>
<li><a href="http://www.atmarkit.co.jp/ait/articles/0505/27/news116_3.html">SQLクリニック（4）：日付データ演算の達人技を伝授する 【第3話】 (3/3) - ＠IT</a></li>
</ul>


<blockquote><p>実は、日本にも複数のタイムゾーンが存在したことが過去にあるようです。それまでJSTとされていたタイムゾーンがこのときCJTとなりました。「Central Japan Time」の略称で、日本中央時間（もしくは中央日本時間）です。</p></blockquote>

<p>少なくとも2013年にCJTを使うことはなさそうなので、これは嬉しくないですね。</p>

<pre><code>&gt;&gt;&gt; jst.localize(datetime.datetime.now())
datetime.datetime(2013, 7, 5, 12, 23, 19, 647283, tzinfo=&lt;DstTzInfo 'Asia/Tokyo' JST+9:00:00 STD&gt;)
</code></pre>

<p>夏時間に対処した時と同じように、localizeしてやれば問題なくJSTが返ってきます。とりあえずlocalizeしておけば安心、なのかな。</p>

<h2>関連エントリ</h2>

<ul>
<li><a href="http://nekoya.github.io/blog/2013/06/21/python-datetime/">Pythonの日付処理とTimeZone</a></li>
<li><a href="http://nekoya.github.io/blog/2013/07/02/python-aware-datetime-dst/">Pythonのdatetimeで夏時間を扱う</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL-python1.2.4でdatetimeから文字列の変換方法が変わった件]]></title>
    <link href="http://nekoya.github.io/blog/2013/07/03/mysql-python-datetime-format/"/>
    <updated>2013-07-03T10:32:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2013/07/03/mysql-python-datetime-format</id>
    <content type="html"><![CDATA[<p>MySQL-python（MySQLdb）を上げたら、今まで通ってたテストでwarningが出るようになりました。</p>

<p><a href="https://github.com/farcepest/MySQLdb1/blob/MySQLdb-1.2.4/MySQLdb/times.py">MySQLdb/times.py</a>で以前は</p>

<pre><code>def format_TIMESTAMP(d):
    return d.strftime("%Y-%m-%d %H:%M:%S")
</code></pre>

<p>こうなっていたものが、</p>

<pre><code>def format_TIMESTAMP(d):
    return d.isoformat(" ")
</code></pre>

<p>こうなったのが原因らしいのだけど、<a href="https://github.com/farcepest/MySQLdb1/blob/MySQLdb-1.2.4/HISTORY">Changelog</a>を見てもそれらしい表記がないので少し経緯を追ってみました。</p>

<p>この変更で何が問題になったかというと、</p>

<pre><code>&gt;&gt; import datetime, pytz
&gt;&gt;&gt; datetime.datetime.now(pytz.utc).isoformat(' ')  # aware
'2013-06-27 01:50:16.156481+00:00'
&gt;&gt;&gt; datetime.datetime.now().isoformat(' ')  # naive
'2013-06-27 10:48:30.696072'
</code></pre>

<p>のように、microsecondや時差を含んだ文字列がSQLに渡って「Warning: Incorrect datetime value: &#8216;2013-06-27 01:50:16.156481+00:00&#8217; for column 〜」という警告が出るようになりました。</p>

<p>履歴を追っていくと、<a href="http://sourceforge.net/p/mysql-python/svn/659/">http://sourceforge.net/p/mysql-python/svn/659/</a> で</p>

<blockquote><p>Use isoformat() instead of strftime() to avoid year limitations of the latter. Fixes #3296395</p></blockquote>

<p>とあって、1900年以前の日付を扱えるようにこの変更を加えたことが分かります。strftime(3)の仕様的にそうなってたけど、そこの制限を外したぜってことらしいです。だけど、この#3296395ってどこのことだ…</p>

<p>該当するチケットは <a href="http://sourceforge.net/p/mysql-python/bugs/311/">#311 executing a datetime column update with year &lt; 1900 fails</a> っぽいけど、BTS移行とかしたんでしょうか。</p>

<p>最初はMySQL5.6でdatetime型がミリ秒対応したらしい（検証してない）ので、それに合わせた施策かなーと思ったらそんなことはなかった。</p>

<p>他にもmicrosecond周りでは <a href="http://sourceforge.net/p/mysql-python/bugs/325/">#325 Datetime fields with microsecond shows as None</a> みたいなチケットが今も動いていたりして、なかなか予断を許さない印象を受けます。</p>

<p>DBのライブラリがdatetimeオブジェクトを適切に扱ってくれるのは素敵だと思ってたけど、なかなか難しいですね。取り急ぎの対処法としては、</p>

<ul>
<li>microsecondやtzinfoを含まないdatetimeオブジェクトだけを扱う</li>
<li>事前に自分で文字列にして渡す</li>
</ul>


<p>のいずれかにわけで、自分のユースケースだとコネクション管理と<a href="http://search.cpan.org/~tokuhirom/SQL-Maker-1.12/lib/SQL/Maker.pm">SQL::Maker</a>の簡易版みたいなことをするラッパーを通しているので、そこで時前でstrftimeして乗り切る感じになりました。</p>

<p>メロスには英語がわからぬ。だが、<a href="https://github.com/farcepest/MySQLdb1/issues/22">issue</a>は切ってみた。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pythonのdatetimeで夏時間を扱う]]></title>
    <link href="http://nekoya.github.io/blog/2013/07/02/python-aware-datetime-dst/"/>
    <updated>2013-07-02T15:07:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2013/07/02/python-aware-datetime-dst</id>
    <content type="html"><![CDATA[<p>「<a href="http://nekoya.github.io/blog/2013/06/21/python-datetime/">Pythonの日付処理とTimeZone</a>」を書いた後、Twitterで指摘をもらっていたのを遅ればせながら検証したので、改めてエントリを起こしてみました。</p>

<blockquote class="twitter-tweet"><p>Pythonの日付処理とTimeZone <a href="http://t.co/KK1B5Fot0V">http://t.co/KK1B5Fot0V</a> datetime を tzinfo 付きで生成する場合は pytz.tzinfo.normalize しないと DST 境界を超えるところで存在しない時刻を作りますよ</p>&mdash; Jun Omae⁽⁶⁶ʲ⁵⁾ (@jun66j5) <a href="https://twitter.com/jun66j5/statuses/348421676503011328">June 22, 2013</a></blockquote>


<script async src="http://nekoya.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p><a href="https://twitter.com/jun66j5">@jun66j5</a>さんありがとうございました。</p>

<p>このへんの背景は<a href="http://pytz.sourceforge.net/">pytzのサイト</a>にありますが、そもそもサマータイムに馴染みがないのでどうあるべきかがしっくりきません。</p>

<h2>標準時と夏時間の切り替わり</h2>

<p>ここでは、ニューヨークが属するTimeZoneを例に話を進めます。まずは基本的な用語の整理から。</p>

<ul>
<li><a href="http://ja.wikipedia.org/wiki/%E5%A4%8F%E6%99%82%E9%96%93">DST</a> … daylight saving time、夏時間（サマータイム）のこと</li>
<li><a href="http://ja.wikipedia.org/wiki/%E6%9D%B1%E9%83%A8%E6%A8%99%E6%BA%96%E6%99%82">EST</a> … 東部標準時、UTCより5時間遅れ（-05:00）</li>
<li><a href="http://ja.wikipedia.org/wiki/%E6%9D%B1%E9%83%A8%E5%A4%8F%E6%99%82%E9%96%93">EDT</a> … 東部夏時間、UTCより4時間遅れ（-04:00）</li>
</ul>


<p>とりあえずWikipediaにリンクしときましたが、他にも「<a href="http://www.time-j.net/">Time-j.net 世界時計 - 世界の時間と時差</a>」というサイトの「<a href="http://www.time-j.net/WorldTime/Location/America/New_York">アメリカ / ニューヨークの時差と現在時刻</a>」がいろいろ参考になりました。</p>

<p>2013年は3月10日の午前2時から11月3日の午前2時までが夏時間らしいです。と一口に言っても、夏時間に突入すると同時に現時刻の定義が変わるし、標準時に戻った時も現時刻の定義が変わるのでややこしいんですよね。</p>

<p>正確には「標準時（EST）の3/10 02:00から」「夏時間（EDT）の11/3 02:00まで」が夏時間の適用期間で、その時刻を迎えた時に切り替わるのでこういうことになるようです。</p>

<pre><code>from datetime import datetime
import pytz

fmt = '%Y-%m-%d %H:%M:%S %z(%Z)'

def dump(year, mon, day, hour, min, sec):
    dt = datetime(year, mon, day, hour, min, sec, tzinfo=pytz.utc)
    print dt.astimezone(ny).strftime(fmt)

ny = pytz.timezone('America/New_York')

dump(2013, 3, 10, 6, 59, 59)  # 2013-03-10 01:59:59 -0500(EST)
dump(2013, 3, 10, 7, 0, 0)    # 2013-03-10 03:00:00 -0400(EDT)
dump(2013, 11, 3, 5, 59, 59)  # 2013-11-03 01:59:59 -0400(EDT)
dump(2013, 11, 3, 6, 0, 0)    # 2013-11-03 01:00:00 -0500(EST)
</code></pre>

<p>2013年3月10日の午前2時という時間は消し飛び、夏時間に突入したという結果だけが残る。と考えれば覚えやすいのではないでしょうか。</p>

<h2>datetimeオブジェクトの作り方</h2>

<p>夏時間に該当するdatetimeオブジェクトを作る時、コンストラクタにtzinfoを渡すとこうなります。</p>

<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; import pytz
&gt;&gt;&gt; ny_tz = pytz.timezone('America/New_York')
&gt;&gt;&gt; datetime(2013, 4, 10, 8, 0, tzinfo=ny_tz).strftime(fmt)
'2013-04-10 08:00:00 EST(-0500)'
</code></pre>

<p>ESTなので夏時間になっていません。これは、pytz.timezone()を単体で呼んだだけでは夏時間の判定ができないため、</p>

<ol>
<li>とりあえずESTのtzinfoを返す</li>
<li>datetimeは渡されたtzinfoを単純に取り込む</li>
</ol>


<p>という動作をして、こういう結果を返してしまうものと思われます。</p>

<pre><code>&gt;&gt;&gt; ny_tz.localize(datetime(2013, 4, 10, 8, 0)).strftime(fmt)
'2013-04-10 08:00:00 EDT(-0400)'
</code></pre>

<p>こちらは日付が確定した後にTimeZone情報を与えているので、夏時間に属するawareなdatetimeオブジェクトが取れています。</p>

<pre><code>def localize(dt):
    print ny_tz.localize(dt).strftime(fmt)

localize(datetime(2013, 3, 10, 1, 59, 59))  # 2013-03-10 01:59:59 EST(-0500)
localize(datetime(2013, 3, 10, 2, 0, 0))    # 2013-03-10 02:00:00 EST(-0500)
localize(datetime(2013, 3, 10, 2, 59, 59))  # 2013-03-10 02:59:59 EST(-0500)
localize(datetime(2013, 3, 10, 3, 0, 0))    # 2013-03-10 03:00:00 EDT(-0400)
</code></pre>

<p>2時になったらキング・クリムゾン発動するんじゃないの…</p>

<pre><code>def normalize(dt):
    print ny_tz.normalize(ny_tz.localize(dt)).strftime(fmt)

normalize(datetime(2013, 3, 10, 1, 59, 59))  # 2013-03-10 01:59:59 EST(-0500)
normalize(datetime(2013, 3, 10, 2, 0, 0))    # 2013-03-10 03:00:00 EDT(-0400)
normalize(datetime(2013, 3, 10, 2, 59, 59))  # 2013-03-10 03:59:59 EDT(-0400)
normalize(datetime(2013, 3, 10, 3, 0, 0))    # 2013-03-10 03:00:00 EDT(-0400)
</code></pre>

<p>こちらは2時台も補正されました。ただし、3/10 02:00〜02:59は存在しない時間なので、02:00は03:00と同時刻として処理されます。</p>

<pre><code>&gt;&gt;&gt; ny_tz.localize(datetime(2013, 3, 10, 2, 0, 0)).astimezone(pytz.utc)
datetime.datetime(2013, 3, 10, 7, 0, tzinfo=&lt;UTC&gt;)
&gt;&gt;&gt; ny_tz.localize(datetime(2013, 3, 10, 3, 0, 0)).astimezone(pytz.utc)
datetime.datetime(2013, 3, 10, 7, 0, tzinfo=&lt;UTC&gt;)
</code></pre>

<p>いずれもUTCに変換してしまえば補正されます。UTCではなくJSTにしても同様ですが、TimeZoneの変換をするなら基準はUTCに置いた方が混乱が少ないでしょう。</p>

<p>ただし、この場合でもコンストラクタにtzinfoを渡してしまうと、</p>

<pre><code>&gt;&gt;&gt; datetime(2013, 3, 10, 2, 0, tzinfo=ny_tz).astimezone(pytz.utc)
datetime.datetime(2013, 3, 10, 7, 0, tzinfo=&lt;UTC&gt;)
&gt;&gt;&gt; datetime(2013, 3, 10, 3, 0, tzinfo=ny_tz).astimezone(pytz.utc)
datetime.datetime(2013, 3, 10, 8, 0, tzinfo=&lt;UTC&gt;)
</code></pre>

<p>このように、後者もESTをベースとして処理されてしまいます。pytzの公式にもあるように、datetimeの実装が今の仕様である以上どうにもならないようです。</p>

<p>夏時間を考慮してdatetimeオブジェクトを作る場合は、以下を基本方針とするのがいいでしょう。</p>

<ul>
<li>コンストラクタにはtzinfoを渡さず、naiveなdatetimeオブジェクトをlocalizeする</li>
<li>存在しない時刻が渡る可能性がある時はnormalizeするかUTCに変換する</li>
</ul>


<h2>timedeltaによる演算と夏時間</h2>

<p>tzinfoが夏時間を考慮してくれない問題は、datetimeオブジェクトを作る時だけでなく、timedeltaによる演算時も同様です。</p>

<pre><code>from datetime import timedelta

def offset(seconds):
    dt = ny_tz.localize(datetime(2013, 3, 10, 1, 59, 59))
    dt += timedelta(seconds=seconds)
    print dt.strftime(fmt)

offset(0)     # 2013-03-10 01:59:59 EST(-0500)
offset(1)     # 2013-03-10 02:00:00 EST(-0500)
offset(3600)  # 2013-03-10 02:59:59 EST(-0500)
offset(3601)  # 2013-03-10 03:00:00 EST(-0500)
</code></pre>

<p>夏時間に突入しても、TimeZoneはESTのままです。</p>

<pre><code>def offset_n(seconds):
    dt = ny_tz.localize(datetime(2013, 3, 10, 1, 59, 59))
    dt += timedelta(seconds=seconds)
    print ny_tz.normalize(dt).strftime(fmt)

offset_n(0)     # 2013-03-10 01:59:59 EST(-0500)
offset_n(1)     # 2013-03-10 03:00:00 EDT(-0400)
offset_n(3600)  # 2013-03-10 03:59:59 EDT(-0400)
offset_n(3601)  # 2013-03-10 04:00:00 EDT(-0400)
</code></pre>

<p>normalizeしてやると、補正されてEDTになります。</p>

<p>ただ、夏時間のように時間の定義が途中で変わるような条件で演算するのはあまりに複雑なので、事前にUTCに変換してしまった方が安全でしょう。</p>

<pre><code>&gt;&gt;&gt; datetime(2013, 3, 10, 6, 59, 59, tzinfo=pytz.utc).astimezone(ny_tz).strftime(fmt)
'2013-03-10 01:59:59 EST(-0500)'
&gt;&gt;&gt; datetime(2013, 3, 10, 7, 0, 0, tzinfo=pytz.utc).astimezone(ny_tz).strftime(fmt)
'2013-03-10 03:00:00 EDT(-0400)'
</code></pre>

<p>astimezoneで変換した場合はnormalizeは不要なので、夏時間を意識する必要はありません。</p>

<p>特にテストを書く場合に、夏時間とその期間外でUTCからの時差が変わってテストケースに影響が出るのは好ましくないと考えます。</p>

<p>本件に限らず複数のTimeZoneを扱う場合は、「内部ではUTCで保持し、出力する段階でlocaltimeに変換する」のが間違いが起きにくいでしょう。文字コードで「内部ではUnicodeで保持し、出力する段階でUTF-8等に変換する」というのと同じですね。</p>

<h2>まとめ</h2>

<ul>
<li>夏時間がある場合はコンストラクタにtzinfoを渡さない</li>
<li>時刻を扱う場合は内部ではUTCで持つと混乱が少ない（はず）</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pythonの日付処理とTimeZone]]></title>
    <link href="http://nekoya.github.io/blog/2013/06/21/python-datetime/"/>
    <updated>2013-06-21T10:04:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2013/06/21/python-datetime</id>
    <content type="html"><![CDATA[<p>日付周りの処理というのはとても難しい問題で、特にTimeZoneが絡むと基本的に大変なことになります。</p>

<p>Pythonは標準で用意されているdatetimeモジュールが高機能なので、それを使っておけば間違いない感があって、そういう意味では安心感があります。</p>

<p>とは言え、その扱いにはやはり注意が必要で、現時点でこうするのがいいかなーと思っていることをつらつらと記録したエントリがこちらです。</p>

<p>基本的にはMacのPython2.7.1で検証して、おやっと思ったところはCentOS5.8のPython2.6.5やUbuntu12.04のPython2.7.3で追試しています。</p>

<p>なお、datetime.datetimeと書くのがだるいので本文中では、</p>

<pre><code>from datetime import datetime
</code></pre>

<p>を前提としています。</p>

<h2>naiveとaware</h2>

<p><a href="http://docs.python.jp/2/library/datetime.html">公式ドキュメント</a>にそのまま載ってるけど、datetimeオブジェクトは自身がTimeZone情報を持つ（aware）場合と、持たない（naive）場合があります。</p>

<p>明示的に指定しない限りnaiveになるため、プログラマは自身が「そのオブジェクトがどのTimeZoneに属するか」を常に間違いなく扱う必要があります。</p>

<p>で、これは当然難しい。JSTとUTCぐらいならまだしも、様々なタイムゾーンを扱うシステムでは常に正しい値を扱うことは至難の業と言ってもいい。</p>

<p>「基本はUTCで扱い、localtimeの場合は変数名にlocalと付ける」みたいなルールで頑張っても、モジュールをまたぐ時に変換間違えて残念なことになりかねません。</p>

<p>これに対して、awareなオブジェクトは内部にTimeZone情報を持っているので、そういうケースでも安心できます。</p>

<pre><code>&gt;&gt;&gt; import pytz
&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; datetime.now(pytz.utc)
datetime.datetime(2013, 5, 10, 7, 38, 56, 442741, tzinfo=&lt;UTC&gt;)
&gt;&gt;&gt; datetime(2013, 5, 16, tzinfo=pytz.timezone('Asia/Tokyo'))
datetime.datetime(2013, 5, 16, 0, 0, tzinfo=&lt;DstTzInfo 'Asia/Tokyo' CJT+9:00:00 STD&gt;)
</code></pre>

<p>こんな感じで、原則として全てのdatetimeオブジェクトはawareな状態で扱うようにしています。utcnow()はtzinfoを受け取れないので、UTCにする場合でも必ずnow()を使います。</p>

<h3>pytzの位置付け</h3>

<p>TimeZoneを表すには<a href="http://pytz.sourceforge.net/">pytz</a>を使っています。可能であればサードパーティのライブラリではなく、全て標準モジュールで済ませたいところですが、pytzは<a href="http://docs.python.jp/3.3/library/datetime.html#tzinfo-objects">Python3.3の公式ドキュメント</a>でも、</p>

<blockquote><p>pytz は最新の情報を含み、使用を推奨されています。</p></blockquote>

<p>とお墨付きが出ているので標準に近いモジュールということで利用しています。</p>

<h3>naiveとawareの変換、あるいはTimeZone変更</h3>

<p>naiveとawareの変換は、<del>公式にあるようにreplaceを使います</del>。naiveなdatetimeオブジェクトとawareなそれでは比較や演算が出来ないので、意外と使う場面はあります。</p>

<p>（2013/07/05修正）replaceするとJSTがCJTと認識される問題があったので、naive→awareの変換にはlocalizeを使用します → <a href="http://nekoya.github.io/blog/2013/07/05/python-datetime-with-jst/">Pythonでdatetimeにtzinfoを付与するのにreplaceを使ってはいけない</a></p>

<p>naive→aware</p>

<pre><code>&gt;&gt;&gt; now = datetime.now()
&gt;&gt;&gt; now
datetime.datetime(2013, 6, 18, 2, 15, 2, 485439)
&gt;&gt;&gt; pytz.utc.localize(now)
datetime.datetime(2013, 6, 18, 2, 15, 2, 485439, tzinfo=&lt;UTC&gt;)
</code></pre>

<p>aware→naive</p>

<pre><code>&gt;&gt;&gt; now = datetime.now(pytz.utc)
&gt;&gt;&gt; now
datetime.datetime(2013, 6, 17, 17, 15, 43, 157502, tzinfo=&lt;UTC&gt;)
&gt;&gt;&gt; now.replace(tzinfo=None)
datetime.datetime(2013, 6, 17, 17, 15, 43, 157502)
</code></pre>

<p>awareなオブジェクトの持っているTimeZone情報の変更は、replaceではなくastimezoneで以下のように。</p>

<pre><code>&gt;&gt;&gt; now = datetime.now(pytz.utc)
&gt;&gt;&gt; now
datetime.datetime(2013, 5, 10, 7, 55, 30, 9529, tzinfo=&lt;UTC&gt;)
&gt;&gt;&gt; now.astimezone(pytz.timezone('Asia/Tokyo'))
datetime.datetime(2013, 5, 10, 16, 55, 30, 9529, tzinfo=&lt;DstTzInfo 'Asia/Tokyo' JST+9:00:00 STD&gt;)
</code></pre>

<h2>UNIXTIMEを扱う</h2>

<p>PythonでUNIXTIMEを得る方法として、よく紹介されるのが</p>

<pre><code>&gt;&gt;&gt; int(time.mktime(datetime.now().timetuple()))
1371682685
</code></pre>

<p>です。intでくくらないと「1371682685.0」のようなfloatが返ってきます。これはこれでいいのですが、datetimeオブジェクトからUNIXTIMEを得ようとすると、</p>

<pre><code>&gt;&gt;&gt; int(time.mktime(datetime(1970, 1, 1).timetuple()))
-32400
&gt;&gt;&gt; int(time.mktime(datetime(1970, 1, 1, tzinfo=pytz.utc).timetuple()))
-32400
&gt;&gt;&gt; int(time.mktime(datetime(1970, 1, 1, tzinfo=pytz.timezone('Asia/Tokyo')).timetuple()))
-32400
</code></pre>

<p>どうやってもUTCを認識してくれない。time.mktimeはtzinfoに対応しておらず、localtimeを受けることになっているのが原因です。</p>

<p><a href="http://docs.python.jp/2/library/time.html">timeモジュールのドキュメント</a>にそのあたりのルールが書いてあって、UTCを扱う場合はcalendar.timegm()を使えとのこと。</p>

<pre><code>&gt;&gt;&gt; calendar.timegm(datetime(1970, 1, 1).timetuple())
0
&gt;&gt;&gt; calendar.timegm(datetime(1970, 1, 1, tzinfo=pytz.utc).timetuple())
0
</code></pre>

<p>今度はうまくいきましたが、入力値をUTCとして解釈するので</p>

<pre><code>&gt;&gt;&gt; calendar.timegm(datetime(1970, 1, 1, tzinfo=pytz.timezone('Asia/Tokyo')).timetuple())
0
</code></pre>

<p>こんな風にlocaltimeの1970-01-01 00:00:00を渡しても0が返ってきます。要注意。</p>

<p>ちなみに、<a href="http://docs.python.jp/2/library/calendar.html#calendar.timegm">calendar.timegm()</a>は</p>

<blockquote><p>関連はありませんが便利な関数で、 time モジュールの gmtime() 関数の戻値のような時間のタプルを受け取り、 1970年を起点とし、POSIX規格のエンコードによるUnixのタイムスタンプに相当する値を返します。実際、 time.gmtime() と timegm() は反対の動作をします。
バージョン 2.0 で追加.</p></blockquote>

<p>なんて紹介されていて、昔はのどかだったんだなぁと思いを馳せる次第です。</p>

<h3>結局どうすればいいのか</h3>

<p>ベンチ取ってみたら、UTCなdatetimeオブジェクトをcalendar.timegm()にかけるのが一番速かったので、現時刻を表すUNIXTIMEを取得するには、</p>

<pre><code>calendar.timegm(datetime.utcnow().timetuple())
</code></pre>

<p>が最適解でしょう。</p>

<p>datetimeオブジェクトを変換する場合は何を優先するかによりますが、基本的には安全性を重視して</p>

<pre><code>calendar.timegm(dt.astimezone(pytz.utc).timetuple())
</code></pre>

<p>とawareなdatetimeオブジェクトを確実にUTCにした上でcalendar.timegm()にかけるのがいいでしょう。</p>

<p>dtが元々UTCの場合はastimezone()は不要ですが、その場合は実行コスト自体が小さくなるのでやはり上記の形式が最適と考えます。</p>

<p>速度を求める場合は、</p>

<ul>
<li>dtがUTCならcalendar.timegm()</li>
<li>dtがlocalならtime.mktime()</li>
</ul>


<p>と変換する時点でdtのTimeZoneを確実に制御してやる必要があります。この場合、datetimeオブジェクト自体もnaiveな方が若干速くなりました。</p>

<p>datetimeオブジェクトに、tzinfoを考慮してUNIXTIMEを算出してくれるメソッドが生えていればこんなに考えなくていいのに…</p>

<h3>strftimeでUNIXTIMEを取る</h3>

<p>ちなみに、プラットフォーム依存なので公式ドキュメントには記載されていませんが、</p>

<pre><code>&gt;&gt;&gt; datetime.now().strftime('%s')
'1371683864'
</code></pre>

<p>strftimeで%sを使うことでUNIXTIMEが取れます。</p>

<pre><code>&gt;&gt;&gt; datetime(1970, 1, 1).strftime('%s')
'-32400'
&gt;&gt;&gt; datetime(1970, 1, 1, tzinfo=pytz.utc).strftime('%s')
'-32400'
</code></pre>

<p>こいつも手元では、localtimeを前提としたtzinfo非対応の挙動を示しました。検証してないけど、strftime(3)を使っててWindows非対応とかそういうことですかね。</p>

<p>ベンチ取ったらcalendar.timegm()よりも遅かったので、特に使うメリットは無さそうです。</p>

<h3>UNIXTIME to datetime</h3>

<p>次にUNIXTIMEからdatetimeオブジェクトを作る方法です。</p>

<pre><code>&gt;&gt;&gt; datetime.utcfromtimestamp(1337914193)
datetime.datetime(2012, 5, 25, 2, 49, 53)
</code></pre>

<p>するとnaiveになってしまいます。先のnow()とutcnow()の関係と同様、utcfromtimestamp()ではなくfromtimestamp()にtzinfoを渡すアプローチを採ります。</p>

<pre><code>&gt;&gt;&gt; datetime.fromtimestamp(1337914193, pytz.utc)
datetime.datetime(2012, 5, 25, 2, 49, 53, tzinfo=&lt;UTC&gt;)
</code></pre>

<h2>datetime.dateもtzinfo非対応</h2>

<p>年・月・日で構成される、dateオブジェクトは残念ながらTimeZone情報を持つことができません。</p>

<p>日付だって時差の影響を受けるのに、どうしてこうなっているのでしょう。残念。</p>

<p>仕方がないので純粋に日付を扱いたい場合も、datetimeオブジェクトを作って時刻関連の情報をreplace()でつぶしています。</p>

<pre><code>&gt;&gt;&gt; datetime.now(pytz.utc).replace(hour=0,minute=0,second=0,microsecond=0)
datetime.datetime(2013, 6, 20, 0, 0, tzinfo=&lt;UTC&gt;)
</code></pre>

<p>replace漏れがあると悲劇につながりかねないのが不安要素ではある。</p>

<p>あと、datetimeもtoday()があって日付だけ取得できるように見えるけど、</p>

<pre><code>&gt;&gt;&gt; datetime.today()
datetime.datetime(2013, 6, 20, 12, 8, 14, 929174)
</code></pre>

<p>時刻も込みで返ってくるので、そういう用途には使えません。</p>

<blockquote><p>datetime.fromtimestamp(time.time()) と等価です
http://docs.python.jp/2/library/datetime.html#datetime.datetime.today</p>

<p>このメソッドは today() と同様ですが、可能ならば time.time() タイムスタンプを通じて得ることができる、より高い精度で時刻を提供します
http://docs.python.jp/2/library/datetime.html#datetime.datetime.now</p></blockquote>

<p>あたりの説明もなんだか微妙…</p>

<h2>strptimeがTimeZoneを無視する</h2>

<p>先日「<a href="http://nekoya.github.io/blog/2013/06/10/strptime-ymd/">本当は怖いstrptimeと%Y%m%dの関係</a>」でも登場したstrptimeですが、TimeZoneの情報を与えてもnaiveなdatetimeオブジェクトしか作ってくれません。</p>

<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; datetime.strptime('2012-06-18 UTC', '%Y-%m-%d %Z')
datetime.datetime(2012, 6, 18, 0, 0)
</code></pre>

<p>仕方がないので、strptimeの後に続けてtzinfoだけ埋め込んでやります。</p>

<pre><code>&gt;&gt;&gt; import pytz
&gt;&gt;&gt; datetime.strptime('2012-06-18 12:31:07', '%Y-%m-%d %H:%M:%S').replace(tzinfo=pytz.utc)
datetime.datetime(2012, 6, 18, 12, 31, 7, tzinfo=&lt;UTC&gt;)
</code></pre>

<h2>まとめ</h2>

<ul>
<li>datetimeオブジェクトはawareな状態で扱おう</li>
<li>UNIXTIMEの扱いはTimeZoneを意識して</li>
<li>UTCを基準にcalendar.timegmとdatetime.fromtimestampがよさそう</li>
<li>dateやstrptimeはtzinfo非対応なので要注意</li>
</ul>


<p>本稿での検証に使ったベンチマークスクリプトは<a href="https://gist.github.com/nekoya/5819512">https://gist.github.com/nekoya/5819512</a>にまとめておきました。</p>

<p>1.4GHzのCore2Duoを積んだMacBookAirだと結構な差が付いたけど、SandyBridge Core i7-2600 @3.4GHzで走らせたら3倍ぐらい速くなってあまり気にならなくなってしまった。買い換え時？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[本当は怖いstrptimeと%Y%m%dの関係]]></title>
    <link href="http://nekoya.github.io/blog/2013/06/10/strptime-ymd/"/>
    <updated>2013-06-10T10:33:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2013/06/10/strptime-ymd</id>
    <content type="html"><![CDATA[<p>「%Y%m%d」をstrptimeで処理すると曖昧になることを今更ながらに知りました。</p>

<p>社内で「201312」を渡すとキモいという話が出て、</p>

<blockquote class="twitter-tweet"><p>Pythonでdatetime.datetime.strptime(&#8216;201312&#8217;, &#8216;%Y%m%d&#8217;)がエラーにならず1月2日として成立するの具合悪いと思うの</p>&mdash; nekoya (@nekoya) <a href="https://twitter.com/nekoya/status/342897090780876800">June 7, 2013</a></blockquote>


<script async src="http://nekoya.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>ってPostしたら<a href="http://twitter.com/hiratara/">@hiratara</a>さんが「2013129と2013130もキモいぞ」と教えてくれました。</p>

<p>普段は%Y-%-%dを使うんだけど、URLに日付を埋め込む場合はデリミタ無しの方が自然だなーと思ったらご覧の有様だよ。</p>

<p>Python2.7.1</p>

<pre><code>&gt;&gt; datetime.strptime('201312', '%Y%m%d')
datetime.datetime(2013, 1, 2, 0, 0)
&gt;&gt; datetime.strptime('2013129', '%Y%m%d')
datetime.datetime(2013, 12, 9, 0, 0)
&gt;&gt; datetime.strptime('2013130', '%Y%m%d')
datetime.datetime(2013, 1, 30, 0, 0)
</code></pre>

<p>なお、Pythonだけでなく他の言語でも見事にバラバラでﾜﾛﾀ。それぞれ最新版じゃないけど、そう変わらない気がする。</p>

<p>Perl5.12.2 Time::Piece</p>

<pre><code>$ perl -MTime::Piece -le 'print localtime-&gt;strptime("201312", "%Y%m%d")'
Sun Dec  1 00:00:00 2013
$ perl -MTime::Piece -le 'print localtime-&gt;strptime("2013129", "%Y%m%d")'
Mon Dec  9 00:00:00 2013
$ perl -MTime::Piece -le 'print localtime-&gt;strptime("2013130", "%Y%m%d")'
Error parsing time at /Users/ryo/perl5/perlbrew/perls/perl-5.12.2/lib/5.12.2/darwin-2level/Time/Piece.pm line 469.
</code></pre>

<p>PHP5.3.15</p>

<pre><code>$ php -r 'var_dump(new DateTime("201312"));'
object(DateTime)#1 (3) {
  ["date"]=&gt;
  string(19) "2013-06-10 20:13:12"
  ["timezone_type"]=&gt;
  int(3)
  ["timezone"]=&gt;
  string(10) "Asia/Tokyo"
}
$ php -r 'var_dump(new DateTime("2013129"));'
object(DateTime)#1 (3) {
  ["date"]=&gt;
  string(19) "2013-05-09 00:00:00"
  ["timezone_type"]=&gt;
  int(3)
  ["timezone"]=&gt;
  string(10) "Asia/Tokyo"
}
$ php -r 'var_dump(new DateTime("2013130"));'
object(DateTime)#1 (3) {
  ["date"]=&gt;
  string(19) "2013-05-10 00:00:00"
  ["timezone_type"]=&gt;
  int(3)
  ["timezone"]=&gt;
  string(10) "Asia/Tokyo"
}
</code></pre>

<p>Ruby1.9.3p194</p>

<pre><code>% irb
irb(main):001:0&gt; require 'date'
=&gt; true
irb(main):002:0&gt; Date.strptime('201312', '%Y%m%d').to_s
ArgumentError: invalid date
        from (irb):2:in `strptime'
        from (irb):2
        from /Users/ryo/.rbenv/versions/1.9.3-p194/bin/irb:12:in `&lt;main&gt;'
irb(main):003:0&gt; Date.strptime('2013129', '%Y%m%d').to_s
=&gt; "2013-12-09"
irb(main):004:0&gt; Date.strptime('2013130', '%Y%m%d').to_s
ArgumentError: invalid date
        from (irb):4:in `strptime'
        from (irb):4
        from /Users/ryo/.rbenv/versions/1.9.3-p194/bin/irb:12:in `&lt;main&gt;'
</code></pre>

<p>%Y%m%dを取る場合は、strptime任せにせず自分でフォーマットのチェックもしておかないと危険ですね。もしくは、おとなしくデリミタ挟むか。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PythonでTest::TCP的なことをするライブラリをPyPIに上げました]]></title>
    <link href="http://nekoya.github.io/blog/2013/05/27/python-tcptest/"/>
    <updated>2013-05-27T16:25:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2013/05/27/python-tcptest</id>
    <content type="html"><![CDATA[<p>Perlでいうところの<a href="http://search.cpan.org/~tokuhirom/Test-TCP-1.27/lib/Test/TCP.pm">Test::TCP</a>相当のことをPythonでやるライブラリをPyPIに上げました。ようやくPyPIデビューです。</p>

<ul>
<li><a href="https://github.com/nekoya/python-tcptest">https://github.com/nekoya/python-tcptest</a></li>
<li><a href="https://pypi.python.org/pypi/tcptest">https://pypi.python.org/pypi/tcptest</a></li>
</ul>


<p>Test::TCPはPerlでテスト時に一時的にサーバを起動したりする処理の基盤となるライブラリです。同等のことをPythonでやるのに適当なものが見当たらなかったので自分で書いたという経緯です。</p>

<p>社内では以前からこの仕組みを使ってテストを書いていたのですが、自社のconfig系のライブラリとの結合を排除して、再構成したものになります。今回こうして公開するにあたって、関数名をオリジナルのPerl版に近付けたり、TestServerの実装を全面的に見直したりしました。</p>

<p>tcptestパッケージにはTest::TCP本体だけでなく、memcachedとredisのテストサーバ実装も含まれています。Perlでは<a href="http://search.cpan.org/~dmaki/Test-Memcached-0.00004/lib/Test/Memcached.pm">Test::Memcached</a>や<a href="http://search.cpan.org/~typester/Test-RedisServer-0.12/lib/Test/RedisServer.pm">Test::RedisServer</a>のように別のライブラリとしてリリースされていますが、名前空間がバラバラになるのも微妙な気がしたので同一のパッケージにまとめました。</p>

<p>PyPIにアップロードすること自体は参考資料もたくさんあり難しくないのですが、どういう名前付けをすべきかなど運営上のルールが今ひとつ分からず、まだ戸惑っている面があります。大文字小文字とか-_.のどれで区切るのかとか。あと、bdistとかbdist_eggはPure Pythonのライブラリだと不要だと思うけどよく分からない。</p>

<p>なお、今回のtcptestは最初test.tcpという名前空間を使おうとしたのですが、Python標準のtestパッケージと干渉することが判明したので衝突回避のためこの名前になりました。</p>

<p>自社プロダクト間の名前空間であれば、pkgutil.extend_pathを使って回避するのですが、標準ライブラリはともかくとして、PyPIのライブラリ同士での衝突はどう回避してるんだろう。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ベンチャーで働くエンジニアに必要な「勇気」]]></title>
    <link href="http://nekoya.github.io/blog/2013/04/12/pluck/"/>
    <updated>2013-04-12T09:59:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2013/04/12/pluck</id>
    <content type="html"><![CDATA[<h2>「恐怖」を知ること</h2>

<p>35歳が目前に迫りつつある中、ぼちぼちスピリチュアルなことも書いていこうかと思う今日この頃です。</p>

<p>これまで十数年、小さな会社やフリーランス、大企業（はすぐ辞めたけど）を渡り歩いてきて改めてベンチャーの面白さを実感しています。</p>

<p>様々な要素がありますが、その最たる物は「エンジニアが会社の命運を握っている」という紛れもない事実です。自社でプロダクトを開発しているベンチャーにおいて、どんなに立派な経営理念やビジネスモデルも動かないシステムの前ではクソの役にも立ちません。</p>

<p>そして、それはそのままエンジニアの過ちが会社を危機に陥れるリスクを意味します。言ってしまえば「ワンクリックデプロイ」が「ワンクリック倒産」へと直結するかもしれないのです。省力化そのものは目指すべきですが、自分の行為が内包するリスクは忘れてはならないのです。</p>

<p>「何か」が起きてしまった時に上長の責任だ、確認ミスだと逃げることは簡単ですが、ベンチャーは一人一人の裁量の最大化をよしとする文化です。その中で大企業では得られない自由を享受しながら、自らは何のリスクも負わずにいられるわけがないのです。</p>

<p>こういう時に「責任を持ってやります」なんて発言が出来る人はそれこそ恐怖を知らない。事業あるいは会社そのものが無くなることに一介のエンジニア責任を負えるのか。正直なところ責任の取りようなどありません。</p>

<p>もちろん、全てのエンジニアがいつもそこまでの危機に直面することはありません。しかし、本質的にそうしたリスクが内在していることと向き合えないエンジニアは、ベンチャーにおいて重用されることはないでしょう（あえて重用されないよう振る舞うという生き方もあります）。</p>

<p>ベンチャーで働く上で忘れてはならないのが、この「自分の責任能力の及ばない仕事をこなすこと」への恐怖です。</p>

<h2>恐怖を我がものとする</h2>

<p>では、その恐怖にどう立ち向かえばいいのか。身も蓋もない言い方ですが、日々やれることをただやるしかないのです。</p>

<p>エンジニアには何が出来るのか。</p>

<ul>
<li>「ここがコケたら何が起きるのか」を想像し、最悪の事態を引き起こさないように手を打つ。</li>
<li>間違いが起こりにくいようにコードを明確にし、テストを厚くする。</li>
<li>システムが正常に稼働していることを確認するため。そして、何かあった時に素早く状況を把握し、適切な対応が出来るよう、ログを吐く。</li>
<li>監視スクリプトを仕込み、アラートには24時間365日すぐに対応する。</li>
<li>サービスのコードだけでなく、ビジネス要件やインフラも理解し、状況把握の早さと正確さを上げる。</li>
</ul>


<p>こうした要素の一つ一つが必要不可欠です。目新しいものはないし、全て当たり前と言えば当たり前。しかし、これら全てを一人でこなせるようになるには一朝一夕では難しいのも確かです。</p>

<p>では、まず何をすべきか。やはりテストを書くことが誰にでも出来て、確実なリターンを得られる備えでしょう。</p>

<p>「テストは不安を解消するもの」とはよく言われることですが、ベンチャーで働くエンジニアにとってはより切実です。</p>

<p>テストは不安などという生っちょろいものではなく「恐怖を克服するためのもの」なのです。</p>

<p><a href="http://kau.li/">Kauli</a>ではそんな勇気のすばらしさを知るエンジニアを絶賛募集中です。<a href="http://twitter.com/nekoya">@nekoya</a>までDください（思った以上に読まれているのであさまし追記）。</p>

<h2>そして君の未来にこの言葉を持って行けッ！</h2>

<p>いくら強くてもこいつら屍生人は『テスト』を書かん！　ノミと同類よォーッ！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UMLも捨てたもんじゃない]]></title>
    <link href="http://nekoya.github.io/blog/2013/04/01/useful-uml/"/>
    <updated>2013-04-01T10:30:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2013/04/01/useful-uml</id>
    <content type="html"><![CDATA[<p>UML、最近はあまり名前を聞くこともなくなってきた感があります。</p>

<p>「<a href="http://kohada.2ch.net/test/read.cgi/prog/1314799400/">UMLなんていらない</a>」なんてスレもあったりして、どうにも廃れた物と見る向きもあるようです。</p>

<p>「<a href="http://b.hatena.ne.jp/search/tag?safe=on&amp;sort=popular&amp;q=uml&amp;users=100">UML</a>」タグではてブの人気エントリを探しても、2005〜2007年ぐらいのものが目立つので、注目度という意味では流行ではないのは確かなのかなぁとは思います。</p>

<p>が、このところ有用性を改めて実感することが多いので「UMLいいよ」というエントリを書きます。</p>

<p>上記のスレは賛否両論併せてなかなかいい具合に意見が出ていて面白いのですが、以下を抑えていれば認識としてはいいのではないかと思います。</p>

<ul>
<li>UMLは設計の技法ではない</li>
<li>頭の中を整理するため、あるいは人と共有する際の表現技法である</li>
</ul>


<p><a href="http://kau.li/">弊社</a>では、新しく入社したメンバーにプロダクトの設計を共有したり、新機能の開発をする際の社内レビューなどの際に、シーケンス図っぽいものやクラス図っぽいものを使うことがよくあります。</p>

<p>いきなりコードを読み書きしたり、文章に落とすよりも意志の共有がうまくいく感があって、このところ特に積極的に使うようにしているのですが、手応えは強く感じています。</p>

<p>UMLの厳密な書式ルールには全くこだわりはなく、大まかなイメージだけ伝われば、細かい部分は口頭でフォローすれば十分だと考えていています。そういう意味ではUMLを正しく使っているとは言えないのかも知れませんが、それはそれでいいんじゃないのと。</p>

<p>「廃れた」というよりはある程度のところまで浸透して、ふつうに使われるようになったので、大々的に取り沙汰されることがなくなってきただけではないかという気もしますが、それにしてもWeb+DBやSDで見かけないのはどうなのかなぁ…</p>

<p>UMLと併せて「オブジェクト指向で設計する」みたいなのもあまり目にしない印象があります。自分としてはプログラマとしての根幹を支えるとても大切な技術だと思うのですが、最近は雑誌などでもあまり目にすることがなくて寂しい限りです。</p>

<p>若いエンジニアが責務の切り分けや命名に苦心しているのを見るにつけ、この手の話題はもっと定期的に取り沙汰されてもいいのになぁと思うことがままあります。</p>

<p>面接の時にもこのあたりの質問をするべきか、最近はそんなに重視されないのか迷ったこともありましたが、一頃話題になった<a href="http://www.crackingthecodinginterview.com/content/cracking-coding-interview">Cracing The Coding Interview</a>を読むと、多くの企業が採用に際してオブジェクト指向設計についての技術的な質問項目を設けているというエピソードがあり、それ以来迷うことなく、面接時に積極的にこの手の質問を振るようにしています。</p>

<p>あまり細かい部分を追いかける必要はないし、使えば皆が幸せになれるとか言うつもりもないけど、このへんのテーマは知識として身につけておくとお得なので是非。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[githubでdiff --ignore-space-changeを見る方法]]></title>
    <link href="http://nekoya.github.io/blog/2013/03/26/github-diff-ignore-space-change/"/>
    <updated>2013-03-26T15:15:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2013/03/26/github-diff-ignore-space-change</id>
    <content type="html"><![CDATA[<p>Python書いてると、モジュールの関数をクラスに抽出するリファクタリングとかで、git diff &#8211;ignore-space-changeする機会が多いですね。</p>

<p>githubでdiffを見る時にも&#8211;ignore-space-change出来たらなぁと思ったら、mizzy（@gosukenator）さんから神の声が！</p>

<blockquote class="twitter-tweet"><p>@<a href="https://twitter.com/nekoya">nekoya</a> ?w=1 とURLにつけるといいみたいですよ <a href="https://t.co/3iuAcB3Stp" title="https://github.com/blog/967-github-secrets">github.com/blog/967-githu…</a></p>&mdash; Gosuke Miyashita (@gosukenator) <a href="https://twitter.com/gosukenator/status/316431837444595713">March 26, 2013</a></blockquote>


<script async src="http://nekoya.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>というわけで、githubでdiff画面開いて、URLに?w=1を付ければOKでした。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PerlのCrypt::CBCとPythonのPyCryptoで暗号文字列をやりとりする]]></title>
    <link href="http://nekoya.github.io/blog/2013/03/12/python-crypt-cbc/"/>
    <updated>2013-03-12T09:49:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2013/03/12/python-crypt-cbc</id>
    <content type="html"><![CDATA[<p>ここ数年はPerlで暗号を扱う時は<a href="http://search.cpan.org/~jesus/Mcrypt-2.5.7.0/Mcrypt.pm">Mcrypt</a>を使っていますが、少し前の時代だと<a href="http://search.cpan.org/~lds/Crypt-CBC-2.32/CBC.pm">Crypt::CBC</a>を使ったりしてました。世間の流れは知らないけど、Mcrypt使っておけば他のシステムとデータをやりとりする時にお互いやりやすいよねという。</p>

<p>Crypt::CBCで作られた暗号文字列をPythonで復号するケースがあったのですが、そのまま素直にやるとうまくいきません。</p>

<p>padding周りかなと思ったけど、どうやらkeyがそのままでは使えないらしい。stackoverflowにズバリそのまま<a href="http://stackoverflow.com/questions/14859006/using-pycrypto-to-decrypt-perl-encrypted-password">Using PyCrypto to decrypt Perl encrypted password</a>があったのでメモ。</p>

<div><script src='https://gist.github.com/5088592.js?file=publish_hex_key.pl'></script>
<noscript><pre><code>use strict;
use warnings;

# http://stackoverflow.com/questions/14859006/using-pycrypto-to-decrypt-perl-encrypted-password

use Crypt::CBC;

my $key = shift or die '[usage] hex_key.pl key';

my $cipher = Crypt::CBC-&gt;new({
        'key'            =&gt; $key,
        'cipher'         =&gt; 'Blowfish',
        'iv'             =&gt; '12345678',
        'regenerate_key' =&gt; 1,
        'padding'        =&gt; 'standard',
        'prepend_iv'     =&gt; 0,
    });

$cipher-&gt;encrypt('ShutTheFuckUpAndWriteSomeCode');
print unpack('H*', $cipher-&gt;key), &quot;\n&quot;;</code></pre></noscript></div>


<p>こんな具合にして変換したkeyをPythonのコードに埋め込みます。</p>

<div><script src='https://gist.github.com/5088592.js?file=decrypt.py'></script>
<noscript><pre><code>import base64
from Crypto.Cipher import Blowfish
from binascii import unhexlify
from struct import pack

key = unhexlify('144a6b229633360207ff9c79016fc49426f1814727b663bc39df05df9a1892073e2812df9492c1e952aac68d1ddfefba635d3a33aba21535')  # &quot;thisiskey&quot;
iv = '123abc45'


def enc(str):
    plen = Blowfish.block_size - len(str) % Blowfish.block_size
    padding = [plen] * plen
    pad_str = str + pack('b' * plen, *padding)
    cipher = Blowfish.new(key, Blowfish.MODE_CBC, iv)
    return base64.urlsafe_b64encode(cipher.encrypt(pad_str))


def dec(str):
    plen = 4 - len(str) &amp; 3
    pad_str = str + '=' * plen
    cipher = Blowfish.new(key, Blowfish.MODE_CBC, iv)
    dec = cipher.decrypt(base64.urlsafe_b64decode(pad_str))
    num_padding = ord(dec[-1])
    return dec[:(-1 * num_padding)]

assert enc('1234567') == '7Zbfy4S_B28='
assert enc('12345678') == '_V5IPxYq4omALzIyl10aMw=='

assert enc('hello world') == 'V6r02_ivXP2ChJ0DGd_7aw=='
assert dec('V6r02_ivXP2ChJ0DGd_7aw==') == 'hello world'
assert dec('V6r02_ivXP2ChJ0DGd_7aw') == dec('V6r02_ivXP2ChJ0DGd_7aw=') == dec('V6r02_ivXP2ChJ0DGd_7aw==') == dec('V6r02_ivXP2ChJ0DGd_7aw===')</code></pre></noscript></div>


<p>あとはpaddingをそれっぽく調整して、こんなもんでいけたっぽいです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[redisのバックアップは慎重に]]></title>
    <link href="http://nekoya.github.io/blog/2013/02/26/redis-backup/"/>
    <updated>2013-02-26T23:06:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2013/02/26/redis-backup</id>
    <content type="html"><![CDATA[<iframe src="http://rcm-jp.amazon.co.jp/e/cm?lt1=_top&bc1=000000&IS2=1&nou=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=studiomweblog-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=4774155071" style="float:left;width:120px;height:240px;margin:0 1em 1em 0" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>


<p>皆様におかれましては、WEB+DB PRESSの最新号のRedis特集は既にご覧頂いたかと存じます。</p>

<p>弊社では1年ほど前から広告配信に関する様々な部分でRedisを使っています。まだ2.4系なので、2.6の新機能とか新鮮でした。</p>

<p>本番環境でRedisを運用する上で、強く訴えたい注意点は「RDBが壊れることがある」ということです。</p>

<p>「RDBがあるからインスタンスが落ちても平気だぜ」とか思ってると、RDBが壊れてリストア失敗→データ消失ということになりかねません。ファイルにdumpされるからと安心していると痛い目に遭うかも知れません。</p>

<p>（2013/02/27追記）今のところ壊れたのはハード障害が怪しい場面のみです。「RDB壊れるとかRedis使えねー」とかそういう話ではまったくありません。誤解無きよう。壊れる時はRedisじゃなくても壊れます。自分のユースケースではTokyo Cabinet/Tyrantからの乗り換えだったので「RDBの修復自体がサポートされていない」というのが一番の注意点でした（AOFは育ちすぎるのと、I/O発生しすぎで見送り）。</p>

<p>Redisにはredis-check-dump, redis-check-aofというファイルのチェックツールが同梱されています。</p>

<p>redis-check-aofには&#8211;fixオプションがあり、ディスクに保存されたAOFログの復旧を試みることが出来ますが、redis-check-dumpにはそういったオプションはありません。ちゃんと準備しておかないと、RDBが壊れていることは確認できても、それを修復することはかなわず途方に暮れることになります。</p>

<p>ふつうに使っていてRDBが壊れることはそうそうないのは確かですが、メモリ故障などのハード障害のあおりを受けてクラッシュすることはあります。ハード障害に対してはレプリケーションは有効な対策ですが、RDB自体のバックアップもきっちり取っておきたいもの。</p>

<p>なので、ごくごく単純ですがRedisサーバでのRDBのバックアップは</p>

<ol>
<li>RDBファイルの待避</li>
<li>redis-check-dumpで検査</li>
<li>bzip2で固める</li>
<li>バックアップキューに突っ込む</li>
</ol>


<p>という手順で取っています。</p>

<p>キューに登録しておくと、バックアップサーバが後でrsyncしてくれるような簡単なジョブキューの仕組みをRedisのSortedSetを使って作っています。</p>

<p>なお、アプリケーションレベルでのRedisの使い方については<a href="http://www.manning.com/carlson/">Redis in Action</a>が実例豊富でお勧めです。データ型の解説などもじっくりたっぷり解説してあるので、これからRedisを始めようという人はWEB+DBの特集を見た上で、この本を読むのがよいと思います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[get_user()の何がいかんのか]]></title>
    <link href="http://nekoya.github.io/blog/2013/02/20/what-about-get-user/"/>
    <updated>2013-02-20T08:30:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2013/02/20/what-about-get-user</id>
    <content type="html"><![CDATA[<p><a href="http://nekoya.github.com/blog/2013/02/12/dont-say-check-xxx/">先のエントリ</a>で以下のように述べた伏線の回収エントリとなります。</p>

<blockquote><p>そして、get_user()という名前はサンプルコードにはありがちだが、この名前も闇が深いと思っている。これについてはまた別途取り上げたい。</p></blockquote>

<p>このメソッドを構成する単語であるget, userともに問題があると考えており、それぞれについて見ていきます。</p>

<h2>Userとは具体的に何か</h2>

<p>これはよくある話で、まず自問すべきは「そのUserの定義を教えてください」である。</p>

<p>多くの業務システムではユーザ（アクタ）が複数存在しており、単に「ユーザ」と言った場合に指す対象が文脈によって異なることが多い。</p>

<p>これに対しては、Employee, Staff, Administrator, Visitor, Sponsorなど別の具体的な単語に置き換えられないかを検討することになる。</p>

<p>「ユーザ」が一意なシステムであればUserと名付けるのも妥当だろう（SNSなどが該当するだろうか）。</p>

<p>userについては、より具象化した名前が見付からないかよく検討しましょう、という話で簡単に終わる。</p>

<h2>get_XXX()という名前</h2>

<p>このgetという名前についてはここ数年に渡って思うところがあり、もやもやしていたが、この話題を通してある程度は自分のスタンスが見えてきた。</p>

<p>個人的な経験から、近年のプログラム言語はメソッドとプロパティ（メンバ変数）の境界線が曖昧になる方向に進んでいると感じている。</p>

<p>具体的には、PerlでMoose系モジュールによるlazyとdefaultを使ったアクセサと初期値の定義や、Pythonの@propertyがそう感じるに至った体験である。また、JavaScriptでもクロージャを使うことで似たような感覚に陥ることがある。</p>

<p>ここから生まれた疑問が「メソッドや関数への参照を変数に格納可能な言語において、その内容が現物の値そのものなのか、何らかの処理の結果なのかを区別することに意味はあるのか」というものだ。</p>

<p>書籍『リーダブルコード』では、</p>

<blockquote><p>多くのプログラマは、getで始まるメソッドはメンバの値を返すだけのアクセサ」であるという規約に慣れ親しんでいる。この規約を守らなければ誤解を招く可能性がある。</p></blockquote>

<p>として、get*()にコストの高い処理を組み込むことを戒め、</p>

<blockquote><p>コストの高さが事前にわかるように、このメソッドはcoputeMean()などの名前に変えるべきだろう（あるいは、コストの高くない実装に変えるべきだろう）。</p></blockquote>

<p>と書いている。この論には大筋では同意なのだが、「そもそもgetを付ける必然性はあるのか」という疑念がついて回る。</p>

<p>setterについては言語仕様も含めて一概には言えないが、少なくともgetterはプロパティへのアクセスと区別する必要はないとの思いが日に日に強くなっている。</p>

<p>また、呼び出しのコストについては名前の如何に関わらず、呼び出し元がそこを意識するべきではないとも思う。</p>

<p>少し理想論も入ってくるが、外部に公開しているインタフェースは呼び出し元がその内部の実装を意識することなく利用されるべきであると考えている。非機能要件が機能を制限すべきでない、とも言い換えられる。</p>

<p>現実的には呼び出しコストを完全に無視できないケースは多々あるが、それが命名規則に影響を与えることには違和感がある。</p>

<p>例えば、キャッシュを導入すればそれまで毎回大きなコストがかかっていた処理が、最初の1回だけ高コストで、その後は軽い処理になる。</p>

<p>その計算をアクセサが呼ばれた瞬間でなく、オブジェクトが生成されたタイミングで行えば、メソッドそのものは重い処理ではなくなる。</p>

<p>更には、事前にその集計結果をKVS等に格納することになれば、オブジェクト生成も含めて呼び出しコストの問題は無視できるレベルになるだろう。</p>

<p>このような対策が考えられる問題に対して、命名が影響を受けることには疑問がある。</p>

<p>コストの問題は命名とは別のものとして、別途計測やチューニングの対象とすべきではないか。高コストであっても呼び出し頻度が低ければ問題にならないことも多いだろうし、頻度が高いのであれば、名前で警告するよりもコスト軽減に目を向けた方が実りが多いように思う。</p>

<h2>3行まとめ</h2>

<ul>
<li>抽象化されたサンプルの名前に引きずられるな</li>
<li>アクセサとプロパティの違いは明確にしなくていい</li>
<li>命名と処理コストは別問題として扱え</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ダメなのはcheck_xxxだけではない]]></title>
    <link href="http://nekoya.github.io/blog/2013/02/12/dont-say-check-xxx/"/>
    <updated>2013-02-12T08:23:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2013/02/12/dont-say-check-xxx</id>
    <content type="html"><![CDATA[<p>id:<a href="http://d.hatena.ne.jp/Yamashiro0217/">Yamashiro0217</a>さんの<a href="http://d.hatena.ne.jp/Yamashiro0217/20130210/1360480362">check_xxx がなんでダメなのか - Yamashiro0217の日記</a>が面白かったので、少し掘り下げてみる。</p>

<p>第一印象は「いくら何でも例が恣意的すぎ。check_XXX言うな言いたいだけちゃうんか」だったが、現実は非情であり、こういうコードを押し付けられたこともあるので決して大袈裟ではなかった。</p>

<p>こういう名前が付く場合というのは、往々にしてメソッドの目的が定まっていないことが多い。そこに、is_valid_XXXのような名前を持ち込んで戻り値の型を規定してしまうことは有効なアプローチである。やる人は名前に関わらずどこでもexitするが、それは個別に教育していくしかない。</p>

<p>そんな訳でcheck_XXXは確かに避けたい名前だが、is_valid_x_stateやis_valid_user_about_xもやはりよろしくない。check_user_x_value_and_if_invalid_update_x_and_redirectはネタとしても、その方向性には危険な香りがする。</p>

<p>メソッド名が長くなるのはクラスが自身の責務を外部に放り投げることにつながるからだ。is_valid_user_about_xはその分かりやすい例で、対象となるオブジェクトがUserなのかXなのか分からない。</p>

<p>これは、$user->hasValidX()もしくは$x->isValid()として実装されるべきだろう。メソッド名に対象となりうる物が複数出てきたら、その時点でクラスの責務が揺らいでいるのでリファクタリングした方がよい。</p>

<p>また、メソッド名に具体的な条件を表す文言が出てきた場合は、クラスではなくメソッドが責務を持っている可能性が高いので、これも怪しい匂いである。「メソッド名が処理内容そのままで、何も抽象化されていない」が代表的な症例だろう。</p>

<p>と、ここまで読んで何かおかしいと思ったら、サンプルコードに一つもクラスが無いことに気付いた。オブジェクトが設計されていないので、メソッド名だけを整えたところで根本的な問題が解決しないのだ。</p>

<p>メソッドはオブジェクトの公開インタフェースなので、メソッド自体の名前ももちろん大切だけど、その前提となるオブジェクトのクラス設計の方がもっと大切なので気を付けましょう。クラス設計が不適切だと、名前の付けようもなかったりするし。</p>

<p>元ネタでは簡略化のためにあえてクラスを省略したのかも知れないが、メソッドはオブジェクトと対になって意味を持つものなので、やはり省略すべきではない。</p>

<p>なお、オブジェクトに従属していないPHPの関数はメソッドではなく「サブルーチン」と呼びたい。なので自分には、このサンプルのget_XXXをメソッド名と呼ぶこと自体に違和感がある。</p>

<p>そして、get_user()という名前はサンプルコードにはありがちだが、この名前も闇が深いと思っている。これについてはまた別途取り上げたい。</p>

<p>ちなみに、個人的にはcheck_XXXと聞いて最初に思い浮かぶのはNagiosプラグインなので、boolで成否が返ってくることが期待される。が、Nagiosプラグインもwarn/crit/unknownなど様々な戻り値があるので、確認する対象によっては違う型を返すことがあり、やはり適切でない。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python2.6と2.7でlogging.StreamHandlerのキーワード引数が違う]]></title>
    <link href="http://nekoya.github.io/blog/2013/02/08/python27-stream-handler/"/>
    <updated>2013-02-08T09:12:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2013/02/08/python27-stream-handler</id>
    <content type="html"><![CDATA[<p>CentOS5系からUbuntu12.04への移行を狙っていて、Pythonも2.6.5から2.7.3に上げようかという今日この頃。</p>

<p>logging周りでテストがコケて、何かと思ったらStreamHandlerのキーワード引数が変わっていた。</p>

<ul>
<li><a href="http://docs.python.org/2.6/library/logging.html?highlight=streamhandler#logging.StreamHandler">http://docs.python.org/2.6/library/logging.html?highlight=streamhandler#logging.StreamHandler</a></li>
<li><a href="http://docs.python.org/2.7/library/logging.handlers.html#streamhandler">http://docs.python.org/2.7/library/logging.handlers.html#streamhandler</a></li>
</ul>


<p>Python2.6で</p>

<pre><code>handler = logging.StreamHandler(strm=stream)
</code></pre>

<p>と書いていたところが、2.7では</p>

<pre><code>handler = logging.StreamHandler(stream=stream)
</code></pre>

<p>と書かないと動かなくなっています。StreamHandlerの<strong>init</strong>()では、</p>

<pre><code>def __init__(self, stream=None):
    """
    Initialize the handler.

    If stream is not specified, sys.stderr is used.
    """
    Handler.__init__(self)
    if stream is None:
        stream = sys.stderr
    self.stream = stream
</code></pre>

<p>として受け取っているだけで他の引数もないので、単に</p>

<pre><code>handler = logging.StreamHandler(stream)
</code></pre>

<p>とキーワード引数で渡すのをやめれば動くんだけど、こういう「短縮名じゃない方がいいよね」みたいな深い意味のなさそうな変更をあっさり入れられると萎える…</p>

<p>それとも2.6.5と2.7.3の間にはそういう変更を入れても問題ないとされるぐらいの隔たりがあるのだろうか。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[さくらのVPSにUbuntuを入れる初期設定手順]]></title>
    <link href="http://nekoya.github.io/blog/2013/01/24/sakura-vps-ubuntu/"/>
    <updated>2013-01-24T10:15:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2013/01/24/sakura-vps-ubuntu</id>
    <content type="html"><![CDATA[<p>さくらのVPSは初期設定はCentOS6だけど、Ubuntu入れるのも簡単でいいですね。</p>

<p>ただ、インストール直後は本当にOSを入れただけの無防備な状態で非常に危険です。</p>

<p>最低限の設定を定型化しておかないと怖いので、以下メモ。</p>

<p>手順はUbuntu12.04LTSを前提にしていますが、特別なことはしていないので多少の違いは問題ないはず。</p>

<h2>OSインストール直後の安全確保</h2>

<p>インストール自体はマニュアルに沿ってやればOK。</p>

<p>ただし、パスワードは万が一抜かれてもいいように、普段使っていない捨てパスワードを使う。</p>

<p>起動したら急いでufwを使ってiptablesの設定を入れる。まずは全部閉じる。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo ufw enable
</span><span class='line'>sudo ufw default DENY</span></code></pre></td></tr></table></div></figure>


<p>念のためiptablesの設定を見ておく。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo iptables -L</span></code></pre></td></tr></table></div></figure>


<p>いろいろ出てきたら個別のルールは精査しなくてもとりあえずはOK。</p>

<p>外からのアクセスを遮断したら、その時点で不審なログが無いことを確認する。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo less /var/log/auth.log</span></code></pre></td></tr></table></div></figure>


<h2>SSHの設定</h2>

<p>ひとまず安全が確保されたので、ここからは落ち着いて作業できる。</p>

<p>~/.ssh/が無いので作るところから。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mkdir .ssh
</span><span class='line'>chmod 700 .ssh</span></code></pre></td></tr></table></div></figure>


<p>リモートコンソールのコピペボタンを使って、~/.ssh/authorized_keysを作る。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat &gt; .ssh/authorized_keys
</span><span class='line'>chmod 600 .ssh/authorized_keys</span></code></pre></td></tr></table></div></figure>


<p>パーミッションは644とかでも怒られなかったが、落ち着かないので600にしておく。</p>

<p>SSHの設定もデフォルトのままなので、rootログインとパスワード認証をつぶす。</p>

<p>リモートコンソールでのコピペが結構面倒なので、viで直接編集した方が早いかも。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo sed -i 's/^PermitRootLogin yes/PermitRootLogin no/' /etc/ssh/sshd_config
</span><span class='line'>sudo sed -i 's/^#PasswordAuthentication yes/PasswordAuthentication no/' /etc/ssh/sshd_config
</span><span class='line'>sudo /etc/init.d/ssh reload</span></code></pre></td></tr></table></div></figure>


<p>外からのSSH接続を許可する。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo ufw allow ssh</span></code></pre></td></tr></table></div></figure>


<p>外からrootと適当なユーザ名（user等）で入れないのを確認してから、自分のアカウントでSSH接続する。</p>

<p>これで最低限の安全性を確保したサーバが出来るので、あとはふつうに使う。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pythonのパッケージimportで間接的に参照が生える]]></title>
    <link href="http://nekoya.github.io/blog/2013/01/18/python-package-import/"/>
    <updated>2013-01-18T07:25:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2013/01/18/python-package-import</id>
    <content type="html"><![CDATA[<p>社内のプロダクト開発がPythonに移行したはいいけど、調査・運用系のスクリプトは変わらずPerlで書いてDevsとOpsの分離が進みそうで老害化著しい今日この頃です。</p>

<p>これじゃいかんと思って、ワンライナー以外はPythonで書くようになりました。pull req送るとダメ出しもらえるのでありがたいです。</p>

<p>そんなPythonでパッケージをimportしたりfrom〜importしたりすると、自分のイメージと違う動作をすることがあって新鮮だったのでメモ。</p>

<p>（2013/01/19 barとbazが紛らわしいのでs/baz/hoge/gしました）</p>

<p>main.py</p>

<pre><code>import foo.bar
print foo.hoge.var
</code></pre>

<p>foo/__init__.py</p>

<p>foo/bar.py</p>

<pre><code>from foo.hoge import var
</code></pre>

<p>foo/hoge.py</p>

<pre><code>var = 'DEAAAAAAAATH'
</code></pre>

<p>これでmain.pyを実行すると</p>

<pre><code>$ python main.py
DEAAAAAAAATH
</code></pre>

<p>main.pyではfoo.hogeをimportしていないのに、参照できる。Python 2.6.5, 2.7.1で確認。</p>

<ul>
<li>foo.barが走った時点でfooの名前空間にhogeが取り込まれる</li>
<li>foo.barをimportするとfoo.barだけでなく、fooへの参照も取り込まれる</li>
<li>foo以下のパッケージをimportするとfoo.hoge.varにアクセス可能</li>
</ul>


<p>ということか。</p>

<p>以下追記（2013/01/19）</p>

<p><a href="http://twitter.com/hiratara">@hiratara</a>さんとお話ししたので、少し補足。</p>

<p>（2013/01/22 リンク追加）<a href="https://www.facebook.com/hiratara/posts/10152460490030164">https://www.facebook.com/hiratara/posts/10152460490030164</a></p>

<p>『初めてのPython』によると、from module import name1は</p>

<pre><code>import module
name1 = module.name1
del module
</code></pre>

<p>と理屈の上ではほぼ同じ意味を持ちます、というような記述があって、パッケージでないモジュールでは実際そういう動作をするので「fromで指定したモジュールへの参照は保持されない」と思っていました。</p>

<p>上記のサンプルでは、foo.hogeはどこからも直接importはされず、foo.bar内でfrom〜importの形で参照されているだけなので、foo.hogeへの参照が残ると思っていなかったのです。「ほぼ」であって同一でないのはこういうところなのか、と。</p>

<p>確かにdel foo.hoge的なことをしてしまうと、問題が起こりうるしそこを厳密に管理するのは大変すぎるのでこうなっているのは合理的だけど、今まで考えてなかったなぁというのがこちらのエントリでございます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ウノウとZyngaJapanは別の会社だし、ウノウも時期によっていろいろだったよという話]]></title>
    <link href="http://nekoya.github.io/blog/2012/11/20/unoh-will-never-perish/"/>
    <updated>2012-11-20T08:37:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2012/11/20/unoh-will-never-perish</id>
    <content type="html"><![CDATA[<p>この記事は「全くもってAdvent Calendarじゃない」と評判の<a href="http://atnd.org/events/33478">Unoh Advent Calendar</a>に参加しています。一日遅れたけど…</p>

<p>こういう話は内輪の酒の席でいいじゃないのかと思うけど、「ZyngaJapanが閉鎖されるかも（現時点でそのような公式アナウンスはありません）」という話題が持ち上がった時に、目に付いた「ウノウもこれで終わりか」とか「ウノウの人たちどうなるの」みたいな論調には違和感が強いので、あえて過去を振り返ってみることにしました。</p>

<p>ウノウとZyngaJapanは別の会社だし、そもそもウノウという会社も時期によって大きく姿を変えてきたんだということを、勝手気ままに振り返ってみようというのがこのエントリの趣旨です。</p>

<h2>第一期</h2>

<p>創業から2006年ぐらいのイメージ。</p>

<p>「映画生活」「フォト蔵」のふたつを柱に、エンジニアが何でもかんでもやってたっぽい時期。自分はこの時の中のことを知らないけど、会社にエンジニアしかいなかったので事務仕事やバックオフィス系の雑務も何もかも全てエンジニアがやっていたと聞いた。</p>

<p>ラボブログの被ブクマ数は、実はこの頃が一番多かったっぽい。まだ世の中が情報過多になる前のこの時期にブランドを確立したことは、大きなことだったのだろうなと改めて感じます。</p>

<h2>第二期</h2>

<p>2007年から、「まちつく！」立ち上げぐらい。</p>

<h3>人が一気に増えた</h3>

<p>その後、ZyngaJapan期までを支えることになるエンジニア達の入社もこの時期</p>

<h3>「映画生活」売却</h3>

<p>事業の大きな柱を手放し、次のステージを模索していた</p>

<p>「PHPの会社」というイメージが定着したのはこの時期で、毎日いろんな人が入れ替わり立ち替わりラボブログを更新していた。</p>

<p>自分が在籍してたのはこの時期の中盤あたりで、社外プロジェクトやってました。</p>

<p>あんまり知られてないと思うけど、当時のウノウは社外の面白そうなプロジェクトにエンジニアを出すということもしていました。</p>

<p>ユニークなのは「こういうプロジェクトがあるけど、誰かやりたいですか？」と聞いて、誰もいなかったら案件自体をお断りするというスタンスだったこと。</p>

<p>この体制の象徴的なエピソードは今をときめくgumiが危うく立ち上げ損ねかねなかった事案でしょう。当時の様子が<a href="http://digimaga.net/2011/11/zynga-japan-yamada-gumi-kunimitsu-report/3">「起業は若いうちにやればやるほど得」『Zynga Japan』山田進太郎×『gumi』国光宏尚対談レポート</a>で赤裸々に語られております。</p>

<p>坂田くんという架空の人物のことはよく分からないけど、GoogleもPythonだから仕方ないですね。</p>

<h2>第三期</h2>

<p>ソーシャルゲームで業界が一気に動いた時期。2009年秋、mixiアプリのモバイルプラットフォームが産まれ、独立したサービスとしてコツコツやってた「まちつく！」がそこで大当たりする。この時に一気に「まちつく！」にリリースを寄せてSAPとしての地位を確立したスピード感はかなりのものだったように思う。</p>

<p>この時期、自分はサーバ構築屋として非常勤で週2〜4回ぐらい顔を出してて、少し離れたところから中のことを見ていました。</p>

<p>人数もエンジニア以外も合わせて20人ぐらいだったのが、一気に増えて、ZyngaJapanになるまでの1年足らずで50人を超えるまでになってた。</p>

<p>社内の体制も今までは、各エンジニアが独立採算的なよく言えば自律的な、悪く言えば烏合の衆みたいなものだったのが、この時期には「俺たちはチームだ」という意識が強く働いていたように思います。</p>

<p>そうでなければ恐らく破綻していたし、この時期にそういうマインドを持ったエンジニアが在籍していたことには巡り合わせの妙を感じざるを得ません。</p>

<p>この時期はラボブログの更新も週一がルールになって、やや盛り下がった印象ごあったのだけど、</p>

<p><a href="http://unoh.github.com/">http://unoh.github.com/</a></p>

<p>を見ると元気に更新されてましたね。思い込みｲｸﾅｲ。</p>

<h2>ZyngaJapan期</h2>

<p>そして売却後。この時期のことは知らないので、何とも言えない。</p>

<p>自分はこの買収と時を同じくして離れたのだけど、それは本当に偶然で、3ヶ月ぐらいかけた離れる計画を立ててたら、途中でいきなり話が出てきてあらあらという具合でした。</p>

<p>ラボブログが本当に更新されなくなって、外から見えなくなったのは残念だなぁというぐらい。少なからぬ人にとって「ウノウ=ラボブログ」という認識があるはずなので、そういう意味ではやはりZyngaJapanとウノウは全く別の会社として考えていいと思う。</p>

<p>ウノウ時代からの人ももちろんいたけど、半数以上の人は最初から「ZyngaJapan」に入ったと思われるので、あまりウノウウノウ言うのもおかしいんじゃないかというのが個人的な見解です。</p>

<h2>まとめ</h2>

<p>とまぁ独断で好き勝手に切り分けてみたのだけど、だいたい合ってるのではないだろうかと。</p>

<p>あなたにとって「ウノウ」とは、どの期が思い起こされますか？</p>

<p>それぞれの期で半分ぐらい中の人が入れ替わっていて（ZyngaJapan期は憶測）、新陳代謝の活発度としては悪くない線をいってたと思います。多すぎず、少なすぎず、人は動くけど現場が破綻しない程度のさじ加減。それは間違いなく、根幹を支えていたコアメンバーたちの力によるもので、彼らの尽力たるや、そりゃもうたいへんなものだったわけです。</p>

<p>今はもう皆それぞれの場所で素敵に活躍しているので、一部で観測された「ウノウ復活させればいいんや」的な時計の針を巻き戻すような論調はむしろ夢がないと断言します。</p>

<p>ZyngaJapan期はよく知らないけど、それなりに入れ替わりはあったようだし、ここ一年はコアメンバーの離脱も結構ありました。</p>

<p>なので、今回ZyngaJapanがもし閉鎖されたとしても、皆が知ってる「ウノウの人たち」は大半は既にいないわけです。今も残っているエンジニアたちは、自分が知っている人たちについては強者たちしかいないので「会社が閉鎖なんて気の毒」とか「これから彼らはどうなるんだろう」なんて心配をするのはむしろ失礼なぐらいなので、今までお疲れさまというだけです。</p>

<p>ZyngaJapanという会社に来た人たちとは全然交流がないので分からないけど、彼らのことを案じるならばウノウではなくZyngaJapanに思いを馳せて欲しいし、ZyngaJapanがこれまで積み上げてきたものを評価するのが彼らに対する礼儀ではないかと思います。</p>

<p>まとめのまとめ</p>

<ul>
<li>皆それぞれ元気でやってるんだからそれでいい</li>
<li>ZyngaJapanはZyngaJapanとして頑張ったのだから評価されるべき</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CentOS5でもRPS/RFSでNICが捗る話]]></title>
    <link href="http://nekoya.github.io/blog/2012/11/13/centos5-rps-rfs/"/>
    <updated>2012-11-13T15:52:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2012/11/13/centos5-rps-rfs</id>
    <content type="html"><![CDATA[<p><a href="http://twitter.com/kazeburo">kazeburo</a>さんが<a href="http://blog.nomadscafe.jp/2012/08/centos-62-rpsrfs.html">CentOS6.2での事例</a>を紹介されていますが、CentOS5系でもkernelを上げればRPS/RFSが使えるようになって、NICの負荷状況が劇的に改善します。</p>

<p>やり方は意外に簡単で、<a href="http://elrepo.org/tiki/tiki-index.php">ELRepo</a>から<a href="http://elrepo.org/linux/kernel/el5/x86_64/RPMS/kernel-ml-2.6.35-14.2.el5.elrepo.x86_64.rpm">kernel-ml-2.6.35-14.2.el5.elrepo.x86_64.rpm</a>を落としてきてインストール。</p>

<p>あとは、/boot/grub/menu.lstの設定をdefault=0にしてrebootすればOK。</p>

<pre><code>$ uname -r
2.6.35-14.2.el5.elrepo
</code></pre>

<p>ELRepoはNICのドライバなんかもいろいろ提供してくれるし、古いバージョンのRPMを<a href="http://mirror.ventraip.net.au/elrepo/archive/">archive</a>で提供してくれて非常にいいですね（kernelの過去RPMはないのかな）。</p>

<p>RPS/RFSを有効にする設定はCentOS6と同様です。</p>

<pre><code># echo "f" &gt; /sys/class/net/eth0/queues/rx-0/rps_cpus
# echo 4096 &gt; /sys/class/net/eth0/queues/rx-0/rps_flow_cnt
# echo 32768 &gt; /proc/sys/net/core/rps_sock_flow_entries

# cat /sys/class/net/eth0/queues/rx-0/rps_cpus
0f
</code></pre>

<p>それまで特定のコアだけが他よりも30〜50%ぐらい負荷が高かったのが、各コアにいい具合に分散するようになって、1台で捌けるトラフィックがぐっと多くなりました。</p>

<h2>ip_conntrack_maxと監視系の変更</h2>

<p>kernel 2.6.35を入れることで、それまでの/proc/sys/net/ipv4/ip_conntrack_maxが/proc/sys/net/nf_conntrack_maxに移動します。</p>

<p>この値を見るNagiosプラグインを書いて、NRPE経由で監視してたのが動かなくなったので、プラグインを更新しました。</p>

<ul>
<li><a href="https://github.com/nekoya/nagios-plugins-ip_conntrack_max">https://github.com/nekoya/nagios-plugins-ip_conntrack_max</a></li>
</ul>


<p>/etc/sysctl.confの設定も変わるのですが、既存のサーバと統一するために</p>

<pre><code>net.ipv4.ip_conntrack_max = 524288
net.nf_conntrack_max = 524288
</code></pre>

<p>と両方書いてしまうことにしました。</p>

<p>sysctl -pすると</p>

<pre><code>error: "net.ipv4.ip_conntrack_max" is an unknown key
</code></pre>

<p>って怒られるけど、実際のところは無視されるだけで特に実害無さそう…</p>

<p>Puppetのテンプレートで真面目に判定すればいいんだろうけど、ひとまずこれで。</p>

<p><a href="http://kau.li/jp">弊社</a>ではLVSをUbuntu、GWをVyattaにして自作サーバでNIC叩き回してがんばっていますが、appサーバはこれでまだ戦えそうです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Yokohama.pm#9でトークしてきました]]></title>
    <link href="http://nekoya.github.io/blog/2012/10/30/yokohamapm9/"/>
    <updated>2012-10-30T02:04:00+09:00</updated>
    <id>http://nekoya.github.io/blog/2012/10/30/yokohamapm9</id>
    <content type="html"><![CDATA[<p><a href="http://yokohama.pm.org/2012/09/yokohamapm-9.html">Yokohama.pm #9</a>にて「インターネット広告とPerl、ここ数年の歩み」と題してお話しさせて頂きました。</p>

<iframe src="http://www.slideshare.net/slideshow/embed_code/14813377" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen> </iframe>


<p> <div style="margin-bottom:5px"> <strong> <a href="http://www.slideshare.net/nekoya/perl-14813377" title="インターネット広告とPerl、ここ数年の歩み" target="_blank">インターネット広告とPerl、ここ数年の歩み</a> </strong> from <strong><a href="http://www.slideshare.net/nekoya" target="_blank">Ryo Miyake</a></strong> </div></p>

<p>アドテク関係の人はあまりこういった各言語のコミュニティには姿を現さないイメージが強く、自分もわりとそういう流れに乗るような感じで、ここしばらくあまりオープンとは言えない日々を過ごしていました。</p>

<p>そんな中、YAPCで<a href="http://twitter.com/myfinder">@myfinder</a>さんが「<a href="http://yapcasia.org/2012/talk/show/d1edd2c0-ab9b-11e1-918c-2a656aeab6a4">平均レスポンスタイム50msをPerlで捌く中規模サービスの実装/運用</a>」と題してYAPCでトークして、しかもベストトーク賞3位というかっこいいことをやってのけてくれたことは大変な刺激になりました。</p>

<p>自分が憧れたのはこういう世界だったなーということを思い返している間に、ここ数年のことが思い出されてこういうスライドが出来上がりました。</p>

<p>東京に出てきてからの、この5年間でソーシャルゲーム（主にインフラ）や旅行代理店のサイト（デザインから開発・インフラまで）などもやってきましたが広告というのはなかなかに面白い分野です。</p>

<p>技術的には特異な要素も確かにありますが、とにかく「ふつうのことをふつうにやる」ということに尽きます。</p>

<p>これだけ情報が出そろった今時のWebサービスで未知のトラブルなんてものはそうそうなくて、日々の守りの課題は</p>

<ul>
<li>手を打たないと危ないのは分かっていたが、手が回らなかった</li>
<li>まさかウチの規模でその問題に出くわすとは思わなかった</li>
</ul>


<p>とは言っても、そういう課題に本当に直面出来る現場というのはそうそうないはずです。</p>

<p>手を抜くと痛い目を見る、逆に言えばちゃんとやればちゃんと結果が付いてくるのが広告の面白いところだと思います。</p>

<p>あとは、ビジネスとエンジニアの距離がものすごく近いことも大きな特徴ですね。</p>

<p>発表に関して言えば、<a href="https://itunes.apple.com/jp/app/keynote-remote/id300719251?mt=8">Keynote Remote</a>を初めて使ってみたんですが、思った以上に快適でした。</p>

<p>以前は無線マウスを持って、ポチポチクリックしてスライドを進めるとかやってましたが、次のページが確認出来ると捗りますね。あとは発表中にタイマーが使えれば言うことないのだけど、どうにかならないかな…</p>

<p>今回は資料作りもiPhone大活躍でした。 前日の朝の通勤電車でEvernoteに草稿を書いて、帰りの電車でKeynoteにペタペタ貼り付けていって、帰ってからいろいろ整えるという流れ。これが21世紀のソリューションや！</p>
]]></content>
  </entry>
  
</feed>
